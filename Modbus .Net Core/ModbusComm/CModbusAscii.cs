using System;
using System.Collections.Generic;
using System.Text;
using System.IO.Ports;
//using System.Windows.Forms;
using System.Diagnostics;
using Microsoft.VisualBasic;

using ThreadLock;
using Converter;
using Converter.Modbus;

//OK-1, 
namespace ModbusComm
{
    //后续可以考虑在收到从站返回的信息后，处理数据前先添加LRC校验检查，以及处理返回结果的字节顺序：ABCD/BADC/CDAB/DCBA

    #region "MODBUS ASCII 报文格式 -- 使用ASCII码进行发送和接收(先转换为ASCII码，然后再转换为二进制码进行发送)"

    //起始位                        地址码    功能码    数据      CRC校验       结束符
    //3.5个字符或更多倍数的字符   

    //01 - 读取线圈状态
    //:         地址码         功能码    设置起始地址   读取数量    LRC     回车+换行符
    //1字符     2字符          2字符     4字符          4字符      2字符    2字符
    //1字节     1字节          1字节     2字节          2字节      1字节    2字节

    //02 - 读取输入状态
    //:         地址码         功能码    设置起始地址   读取数量    LRC     回车+换行符
    //1字符     2字符          2字符     4字符          4字符      2字符    2字符
    //1字节     1字节          1字节     2字节          2字节      1字节    2字节

    //03 - 读保持寄存器(short: -32,768 到 32,767)
    //:         地址码         功能码    设置起始地址   读取数量    LRC     回车+换行符
    //1字符     2字符          2字符     4字符          4字符      2字符    2字符
    //1字节     1字节          1字节     2字节          2字节      1字节    2字节

    //04 - 输入寄存器(short:  -32,768 到 32,767)
    //:         地址码         功能码    设置起始地址   读取数量    LRC     回车+换行符
    //1字符     2字符          2字符     4字符          4字符      2字符    2字符
    //1字节     1字节          1字节     2字节          2字节      1字节    2字节

    //05 - 设置单个继电器状态
    //:         地址码         功能码    设置起始地址   设置值      LRC     回车+换行符
    //1字符     2字符          2字符     4字符          4字符      2字符    2字符
    //1字节     1字节          1字节     2字节          2字节      1字节    2字节

    //06 - 设置单个保持寄存器(short:  -32,768 到 32,767)
    //:         地址码         功能码    设置起始地址   设置值      LRC     回车+换行符
    //1字符     2字符          2字符     4字符          4字符      2字符    2字符
    //1字节     1字节          1字节     2字节          2字节      1字节    2字节

    //0F(15) - 设置多个继电器状态
    //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
    //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
    //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

    //10(16) - 设置多个保持寄存器(short:  -32,768 到 32,767)
    //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
    //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
    //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

    #endregion

    /// <summary>
    /// Modbus Ascii通讯类，支持跨线程读写操作；如果是单线程操作，请将 EnableThreadLock 设置为 false 以提升性能
    /// 授权声明：本软件作者将代码开源，仅用于交流学习。如果有商用需求，请联系软件作者协商相关事宜；否则，软件作者保留相关法律赋予的权利。
    /// 免责声明：使用本软件的相关人员必须仔细检查代码并负全部责任，软件作者不承担任何可能的损失(包含可抗力和不可抗力因素)。
    /// </summary>
    public sealed class CModbusAscii : IModbusComm
    {
        /// <summary>
        /// Modbus Ascii通讯类的构造函数
        /// </summary>
        /// <param name="DLLPassword">使用此DLL的密码</param>
        /// <param name="RS232CPortName">串口通讯的端口名称</param>
        /// <param name="baudrate">波段率</param>
        /// <param name="parity">奇偶校验</param>
        /// <param name="stopbits">停止位</param>
        /// <param name="writetimeout">写超时时间</param>
        /// <param name="readtimeout">读超时时间</param>
        /// <param name="ReadSlaveDataOnly">是否只读取从站返回的消息，默认：false</param>
        /// <param name="paraBytesFormat">命令参数：多字节数据的格式</param>
        /// <param name="writeKeepRegisterBytesFormat">写数据：多字节数据的格式</param>
        /// <param name="readRegisterBytesFormat">读输入和保持寄存器数据：多字节数据的格式</param>
        /// <param name="ThreadLockType">线程同步锁类型</param>
        public CModbusAscii(string DLLPassword, string RS232CPortName, eBaudRate baudrate = eBaudRate.Rate_19200,
            Parity parity = Parity.Even, StopBits stopbits = StopBits.One, int writetimeout = 1000,
            int readtimeout = 1000, bool ReadSlaveDataOnly = false, BytesFormat paraBytesFormat = BytesFormat.BADC,
            BytesFormat writeKeepRegisterBytesFormat = BytesFormat.BADC, BytesFormat readRegisterBytesFormat = BytesFormat.BADC,
            ThreadLock.LockerType ThreadLockType = LockerType.ExchangeLock)
        {
            try
            {
                if (DLLPassword == "ThomasPeng" || DLLPassword == "pengdongnan" || DLLPassword == "彭东南" || DLLPassword == "PDN")
                {
                }
                else
                {
                    for (; ; )
                    {
                    }
                }
                
                ParaBytesFormat = paraBytesFormat;
                WriteKeepRegisterBytesFormat = writeKeepRegisterBytesFormat;//BADC
                ReadInputRegisterBytesFormat = readRegisterBytesFormat;//BADC

                ReadKeepRegisterBytesFormat = BytesFormat.BADC;
                ReadCoilBytesFormat = BytesFormat.ABCD;
                ReadInputIOBytesFormat = BytesFormat.ABCD;
                WriteCoilBytesFormat = BytesFormat.ABCD;

                bool bComPortIsAvailable = false;

                string[] AllAvailableComPorts = SerialPort.GetPortNames();
                if (null == AllAvailableComPorts || AllAvailableComPorts.Length <= 0)
                {
                    throw new Exception("计算机中没有任何可用串口通讯端口");
                }
                else
                {
                    for (int i = 0; i < AllAvailableComPorts.Length; i++)
                    {
                        if (RS232CPortName.ToUpper() == AllAvailableComPorts[i].ToUpper())
                        {
                            bComPortIsAvailable = true;
                        }
                        //else
                        //{

                        //}
                    }
                }

                if (bComPortIsAvailable == false)
                {
                    throw new Exception("计算机中没有找到匹配的串口通讯端口：" + RS232CPortName);
                }

                switch (ThreadLockType)
                {
                    default:
                    case LockerType.AutoResetEventLock:
                        SyncLocker = new CAutoResetEventLock();

                        break;

                    case LockerType.ExchangeLock:
                        SyncLocker = new CExchangeLock();

                        break;

                    //case LockerType.CountdownEventLock:
                    //    SyncLocker = new CCountdownEventLock();

                    //    break;
                }

                RS232CPort = new SerialPort();
                RS232CPort.PortName = RS232CPortName;

                BaudRateSetting(baudrate);

                RS232CPort.Encoding = Encoding.UTF8;
                RS232CPort.Parity = parity;
                RS232CPort.StopBits = stopbits;
                RS232CPort.WriteTimeout = writetimeout;
                RS232CPort.ReadTimeout = readtimeout;
                RS232CPort.NewLine = "\r\n";//Modbus Ascii 码通讯的结束符是：回车+换行

                RS232CPort.Open();

                if (bReadSlaveDataOnly == true)
                {
                    RS232CPort.DataReceived += RS232CPort_DataReceived;
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯类初始化时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }
            }
        }

        #region "Ascii-通讯方式下返回字符串中信息对应位置的定义"

        //未成功执行读命令
        //Modbus Ascii(COM3)发送字符串 - :010100000001FD
        //Modbus Ascii(COM3)收到字符串 - :0181017D

        //未成功执行写命令
        //写操作记录：Modbus Ascii(COM3)发送字符串 - :01050000FF00FB
        //写操作记录：Modbus Ascii(COM3)收到字符串 - :01850179

        //成功执行写命令1890854201
        //写操作记录：Modbus Ascii(COM3)发送字符串 - :01100000000204253970B467
        //写操作记录：Modbus Ascii(COM3)收到字符串 - :011000000002ED

        //成功执行读命令，结果值：1890854201
        //Modbus Ascii(COM3)发送字符串 - :010300000002FA
        //Modbus Ascii(COM3)收到字符串 - :010304253970B476

        // 1   - :
        // 2~3 - 从站地址
        // 4~5 - 功能码
        // 6~7 - 错误码(命令执行失败)；数据字节长度(命令执行成功)
        // 8~(N-2) - 有效数据起始位置
        // 最后2个字符为LRC校验码值

        /// <summary>
        /// Ascii-通讯方式，从站地址：第2~3字符(如果用字节处理，相应值/2)，收到从站返回的字符串中，从站地址码的位置[2] -- 第2个字符，用于Strings.Mid() 函数
        /// </summary>
        public const int PosOfSlaveAddressInAsciiReceivedString = 0x2;

        /// <summary>
        /// 接Ascii-通讯方式，功能码：第4~5字符(如果用字节处理，相应值/2)，收到从站返回的字符串中，功能码的位置[4] -- 第4个字符，用于Strings.Mid() 函数
        /// </summary>
        public const int PosOfFuncCodeInAsciiReceivedString = 0x4;

        /// <summary>
        /// 接Ascii-通讯方式，错误码：第6~7字符(如果用字节处理，相应值/2)，收到从站返回的字符串中，错误码的位置[6] -- 第6个字符，用于Strings.Mid() 函数
        /// </summary>
        public const int PosOfErrorCodeInAsciiReceivedString = 0x6;

        /// <summary>
        /// 接Ascii-通讯方式，数据字节长度：第6~7字符(如果用字节处理，相应值/2)，收到从站返回的字符串中，数据字节长度的位置[6] -- 第6个字符，用于Strings.Mid() 函数
        /// </summary>
        public const int PosOfDataLengthInAsciiReceivedString = 0x6;

        /// <summary>
        /// 接Ascii-通讯方式，有效数据起始位置：第8字符(如果用字节处理，相应值/2)，收到从站返回的字符串中，有效数据的起始位置，默认值8
        /// </summary>
        public const int StartPosOfDataInAsciiReceivedString = 0x8;

        #endregion

        #region "变量定义"

        /// <summary>
        /// 是否已经建立连接
        /// </summary>
        public bool IsConnected
        {
            get { return bIsConnected; }
        }

        /// <summary>
        /// 是否已经建立连接
        /// </summary>
        private bool bIsConnected = false;

        /// <summary>
        /// 释放资源标志
        /// </summary>
        bool bIsDisposing = false;

        /// <summary>
        /// 只读模式下，Modbus通讯返回数据的结果解析类对象的队列
        /// </summary>
        Queue<CReadbackData> qReceivedDataQueue = new Queue<CReadbackData>();

        /// <summary>
        /// 只读模式下，Modbus通讯返回数据的结果
        /// </summary>
        /// <returns></returns>
        public CReadbackData DequeueReceivedData()
        {
            if (qReceivedDataQueue.Count > 0)
            {
                return qReceivedDataQueue.Dequeue();
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// 是否只读取从站返回的消息，适用于从站主动发送的情况
        /// </summary>
        bool bReadSlaveDataOnly = false;

        /// <summary>
        /// 命令参数：多字节数据的格式
        /// </summary>
        public BytesFormat ParaBytesFormat { get; set; }//internal

        /// <summary>
        /// 写线圈数据：多字节数据的格式
        /// </summary>
        public BytesFormat WriteCoilBytesFormat { get; set; }//internalinternal set { WriteCoilBytesFormat = BytesFormat.ABCD; } }

        /// <summary>
        /// 写保持寄存器数据：多字节数据的格式
        /// </summary>
        public BytesFormat WriteKeepRegisterBytesFormat { get; set; }//internal

        /// <summary>
        /// 读输入寄存器数据：多字节数据的格式
        /// </summary>
        public BytesFormat ReadInputRegisterBytesFormat { get; set; }//internal

        /// <summary>
        /// 读保持寄存器数据：多字节数据的格式
        /// </summary>
        public BytesFormat ReadKeepRegisterBytesFormat { get; set; }//internal

        /// <summary>
        /// 读线圈数据：多字节数据的格式，默认值：BytesFormat.ABCD
        /// </summary>
        public BytesFormat ReadCoilBytesFormat { get; set; }//internalinternal set { ReadCoilAndInputBytesFormat = BytesFormat.ABCD; } }

        /// <summary>
        /// 读输入离散信号数据：多字节数据的格式，默认值：BytesFormat.ABCD
        /// </summary>
        public BytesFormat ReadInputIOBytesFormat { get; set; }//internal

        /// <summary>
        /// 回复帧的最小长度:2
        /// </summary>
        const int iMinLengthOfResponse = 2;

        /// <summary>
        /// 同步线程锁
        /// </summary>
        ITheadLock SyncLocker = null;// new CAutoResetEventLock();//CAutoResetEventLock

        /// <summary>
        /// 启用线程锁标志
        /// </summary>
        bool bEnableThreadLock = true;

        /// <summary>
        /// 启用线程锁标志
        /// </summary>
        public bool EnableThreadLock
        {
            get { return bEnableThreadLock; }
            set { bEnableThreadLock = value; }
        }

        /// <summary>
        /// 软件作者：彭东南, southeastofstar@163.com
        /// </summary>
        public string Author
        {
            get { return "【软件作者：彭东南, southeastofstar@163.com】"; }
        }

        /// <summary>
        /// 处理从站返回的信息时使用处理字节的方式，默认值：false
        /// </summary>
        bool ProcessFeedbackDataByBytes = false;

        /// <summary>
        /// System.Threading.Thread.Sleep的等待时间(ms)
        /// </summary>
        int iSleepTime = 1;

        /// <summary>
        /// 等待从站返回信息的时间(ms)
        /// </summary>
        int iWaitFeedbackTime = 500;

        /// <summary>
        /// 等待从站返回信息的时间(ms)，范围：50~3000
        /// </summary>
        public int WaitFeedbackTime
        {
            get { return iWaitFeedbackTime; }
            set
            {
                if (value >= 50 && value <= 3000)
                {
                    iWaitFeedbackTime = value;
                }
            }
        }

        /// <summary>
        /// 保存接收到的信息到日志
        /// </summary>
        public bool bSaveReceivedStringToLog = true;

        /// <summary>
        /// 保存发送的信息到日志
        /// </summary>
        public bool bSaveSendStringToLog = true;

        /// <summary>
        /// 错误信息队列
        /// </summary>
        private Queue<string> qErrorMsg = new Queue<string>();

        /// <summary>
        /// 是否使用提示对话框显示信息，默认 false
        /// </summary>
        public bool ShowMessageDialog = false;

        /// <summary>
        /// 获取或设置奇偶校验检查协议
        /// </summary>
        public Parity Parity
        {
            get { return RS232CPort.Parity; }
            set { RS232CPort.Parity = value; }
        }

        /// <summary>
        /// 获取或设置每个字节的标准停止位数
        /// </summary>
        public StopBits StopBits
        {
            get { return RS232CPort.StopBits; }
            set { RS232CPort.StopBits = value; }
        }

        /// <summary>
        /// 获取或设置写操作未完成时发生超时之前的毫秒数
        /// </summary>
        public int WriteTimeout
        {
            get { return RS232CPort.WriteTimeout; }
            set { RS232CPort.WriteTimeout = value; }
        }

        /// <summary>
        /// 获取或设置读取操作未完成时发生超时之前的毫秒数
        /// </summary>
        public int ReadTimeout
        {
            get { return RS232CPort.ReadTimeout; }
            set { RS232CPort.ReadTimeout = value; }
        }

        /// <summary>
        /// 起始位字符(:)
        /// </summary>
        public const string Prefix = ":";

        /// <summary>
        /// 结束符(回车+换行)
        /// </summary>
        public const string Suffix = "\r\n";

        /// <summary>
        /// 起始位字符(:)的字节
        /// </summary>
        public const byte PrefixByte = 0x3A;

        /// <summary>
        /// 结束符(回车+换行)的字节数组
        /// </summary>
        public static byte[] SuffixBytes
        {
            get { return new byte[] { 0x0D, 0x0A }; }
        }

        /// <summary>
        /// 进行Modbus Ascii通讯的串口实例化对象
        /// </summary>
        SerialPort RS232CPort = null;

        /// <summary>
        /// 波特率设置
        /// </summary>
        eBaudRate eBaudRateSetting = eBaudRate.Rate_19200;

        /// <summary>
        /// 串口是否已经打开
        /// </summary>
        public bool IsOpened
        {
            get
            {
                if (null == RS232CPort)
                {
                    return false;
                }
                else
                {
                    return RS232CPort.IsOpen;
                }
            }
        }

        #region "波特率设置"

        /// <summary>
        /// 获取当前的波特率(bps)；设置波特率时，先使用函数BaudRateSetting设置为eBaudRate.Rate_UserDefine
        /// </summary>
        public int BaudRate
        {
            get { return RS232CPort.BaudRate; }
            set
            {
                if (eBaudRateSetting == eBaudRate.Rate_UserDefine)
                {
                    RS232CPort.BaudRate = value;
                }
            }
        }

        /// <summary>
        /// 设置波特率(bps)
        /// </summary>
        /// <param name="BaudValue"></param>
        public void BaudRateSetting(eBaudRate BaudValue)
        {
            #region "波特率设置"

            eBaudRateSetting = BaudValue;

            switch (BaudValue)
            {
                case eBaudRate.Rate_75:
                    RS232CPort.BaudRate = 75;

                    break;

                case eBaudRate.Rate_110:
                    RS232CPort.BaudRate = 110;

                    break;

                case eBaudRate.Rate_134:
                    RS232CPort.BaudRate = 134;

                    break;

                case eBaudRate.Rate_150:
                    RS232CPort.BaudRate = 150;

                    break;

                case eBaudRate.Rate_300:
                    RS232CPort.BaudRate = 300;

                    break;

                case eBaudRate.Rate_600:
                    RS232CPort.BaudRate = 600;

                    break;

                case eBaudRate.Rate_1200:
                    RS232CPort.BaudRate = 1200;

                    break;

                case eBaudRate.Rate_1800:
                    RS232CPort.BaudRate = 1800;

                    break;

                case eBaudRate.Rate_2400:
                    RS232CPort.BaudRate = 2400;

                    break;

                case eBaudRate.Rate_4800:
                    RS232CPort.BaudRate = 4800;

                    break;

                case eBaudRate.Rate_7200:
                    RS232CPort.BaudRate = 7200;

                    break;

                case eBaudRate.Rate_9600:
                    RS232CPort.BaudRate = 9600;

                    break;

                case eBaudRate.Rate_14400:
                    RS232CPort.BaudRate = 14400;

                    break;

                case eBaudRate.Rate_19200:
                    RS232CPort.BaudRate = 19200;

                    break;

                case eBaudRate.Rate_38400:
                    RS232CPort.BaudRate = 38400;

                    break;

                case eBaudRate.Rate_57600:
                    RS232CPort.BaudRate = 57600;

                    break;

                case eBaudRate.Rate_115200:
                    RS232CPort.BaudRate = 115200;

                    break;

                case eBaudRate.Rate_128000:
                    RS232CPort.BaudRate = 128000;

                    break;

                default:

                    break;
            }

            #endregion
        }

        #endregion

        #endregion

        #region "读 - ok-ok"

        // 起始地址：0x0000~0xFFFF -- 0~65535
        // 读取数量：0x001~0x7D0 -- 1~2000

        #region "读单个/多个线圈 - ok-ok"

        // ok-ok
        /// <summary>
        /// 读取从站单个线圈状态(位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="BitValue">返回线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilBit(byte DeviceAddress, ushort BeginAddress, ref bool BitValue)//ushort ReadDataLength 读取数据长度,   , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节

                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, 1);//ReadDataLength

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                #region "Old codes - No use"

                //try
                //{
                //    Lock();

                //    //清除发送前的接收缓冲区
                //    ClearReceiveBuffer();

                //    // 通过串口发送指令数据给客户端
                //    RS232CPort.Write(byResult, 0, byResult.Length);

                //    if (bSaveSendStringToLog == true)
                //    {
                //        Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //    }

                //    // 读取客户端的返回信息
                //    Stopwatch swUsedTime = new Stopwatch();
                //    swUsedTime.Restart();

                //    while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //    {
                //        if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //        {
                //            Unlock();
                //            throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //            //break;
                //        }

                //        //Application.DoEvents();
                //        System.Threading.Thread.Sleep(iSleepTime);
                //    }

                //    byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());
                //}
                //catch (Exception ex)
                //{
                //    Enqueue("通讯时发生错误：" + ex.Message + "  " + ex.StackTrace);
                //}

                //Unlock();

                #endregion

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                {
                    return false;
                }

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //ReadBackData = sFeedBackFromSlave;

                    //    //(COM1)发送字符串 - :010100000001FD
                    //    //(COM1)收到字符串 - :01010100FD

                    //    //(COM1)发送字符串 - :010100000001FD
                    //    //(COM1)收到字符串 - :01010101FC

                    //    //(COM1)发送字符串 - :010100000001FD
                    //    //(COM1)收到字符串 - :01010100FD   -- 读取成功

                    //    //(COM1)发送字符串 - :010100000001FD
                    //    //(COM1)收到字符串 - :0181017D   -- 读取错误
                    //    //if (byReadData[0] == PrefixByte && byReadData[1] == CModbusFunctionCode.WriteCoil)//
                    //    //{
                    //    //}

                    //    //(COM1)收到字符串 - :01010101FC

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //读取成功
                    //        if (Strings.Mid(sFeedBackFromSlave, 9, 1) == "0")
                    //        {
                    //            //读取的值是0
                    //            BitValue = false;
                    //        }
                    //        else
                    //        {
                    //            //读取的值是1
                    //            BitValue = true;
                    //        }

                    //    //byReadData = null;

                    //        sFeedBackFromSlave = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;

                    //        sFeedBackFromSlave = null;

                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"

                        //ReadBackData = sFeedBackFromSlave;

                        //(COM1)发送字符串 - :010100000001FD
                        //(COM1)收到字符串 - :01010100FD

                        //(COM1)发送字符串 - :010100000001FD
                        //(COM1)收到字符串 - :01010101FC

                        //(COM1)发送字符串 - :010100000001FD
                        //(COM1)收到字符串 - :01010100FD   -- 读取成功

                        //(COM1)发送字符串 - :010100000001FD
                        //(COM1)收到字符串 - :0181017D   -- 读取错误

                        //(COM1)收到字符串 - :01010101FC

                        #endregion

                        //:01010101FC\r\n
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //读取成功
                            if (Strings.Mid(sFeedBackFromSlave, 9, 1) == "0")
                            {
                                //读取的值是0
                                BitValue = false;
                            }
                            else
                            {
                                //读取的值是1
                                BitValue = true;
                            }

                            sFeedBackFromSlave = null;
                            return true;
                        }
                        else
                        {
                            //读取错误
                            //throw new Exception("");

                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个字节的线圈状态，函数是以字节为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字节</param>
        /// <param name="BitValue">返回线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilBit(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref bool[] BitValue)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 250)//读取数据长度，有效值范围：1~250(字节)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~250(字节)");
                //}

                if (BeginAddress + ReadDataLength * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(ReadDataLength * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101FFFE

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :0101017F7E

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :0101017786

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //从站：10101010
                    //    //:   0  1  0  1  0  1  
                    //    //3A 30 31 30 31 30 31 41 41 35 33 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101AA53

                    //    //从站：10100010
                    //    //3A 30 31 30 31 30 31 41 32 35 42 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101A25B

                    //    //从站：11110010
                    //    //3A 30 31 30 31 30 31 46 32 30 42 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101F20B

                    //    //00000000
                    //    //成功执行读命令，结果值：False False False False False False False False 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :01010100FD

                    //    //11010001
                    //    //成功执行读命令，结果值：True True False True False False False True 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101D12C

                    //    //11011111
                    //    //成功执行读命令，结果值：True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101DF1E

                    //    //2个字节的通信记录
                    //    //0000000011011111
                    //    //成功执行读命令，结果值：False False False False False False False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DF001D

                    //    //1000010011011111
                    //    //成功执行读命令，结果值：True False False False False True False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DF8499

                    //    //1111010011011111
                    //    //成功执行读命令，结果值：True True True True False True False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DFF429

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        #region "No use"

                    //        //bool[] bReadResultData = new bool[ReadDataLength * 8];

                    //        //for (int i = 0; i < ReadDataLength; i++)//函数是以字节为单位
                    //        //{
                    //        //    byte[] byTemp = new byte[4];
                    //        //    byTemp[0] = byReadData[i + 7];
                    //        //    byTemp[1] = byReadData[i + 7 + 1];

                    //        //    int iTemp = BitConverter.ToInt16(byTemp, 0);
                    //        //    string sTemp = iTemp.ToString("X4");

                    //        //    sTemp = Strings.Mid(sTemp, 3, 2);


                    //        //    bool[] bTemp = ByteToBitArray(byReadData[i + 7]);//返回数据的值是从第7个字节开始的，2个字节一组
                    //        //    for (int j = 0; j < bTemp.Length; j++)
                    //        //    {
                    //        //        bReadResultData[i * 8 + j] = bTemp[j];
                    //        //    }
                    //        //}

                    //        #endregion

                    //        byte[] byReadResultData = new byte[ReadDataLength];
                    //        //bool[] bReadResultData = new bool[ReadDataLength * 8];
                    //        BitValue = new bool[ReadDataLength * 8];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 2, 2);//8 + i * 2, 2);
                    //            byReadResultData[i] = CConverter.TwoHexCharsToByte(sTemp);

                    //            bool[] bTemp = CConverter.ByteToBitArray(byReadResultData[i]);
                    //            for (int j = 0; j < bTemp.Length; j++)
                    //            {
                    //                BitValue[i * 8 + j] = bTemp[j];//bReadResultData
                    //            }
                    //        }

                    //        //BitValue = bReadResultData;

                    //        //bReadResultData = null;
                    //        byReadResultData = null;

                    //        //BitValue = bReadResultData;

                    //        //bReadResultData = null;

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"

                        //**********
                        //10100000
                        //成功执行读命令，结果值：False False False False False True False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101A05D

                        //***********
                        //11110000
                        //成功执行读命令，结果值：False False False False True True True True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101F00D

                        //***********
                        //10010011
                        //成功执行读命令，结果值：True True False False True False False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101936A

                        //成功执行读命令，结果值：False True False True False False False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :0101018A73

                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :01010159A4
                        //成功执行读命令，结果值：True False False True True False True False 

                        //成功执行读命令，结果值：True True False True False False True False False False False True False True False False 
                        //(COM1)发送字符串 - :010100000010EE
                        //(COM1)收到字符串 - :0101024B2889

                        //成功执行读命令，结果值：True True False True False False True False False False False True True True True True 
                        //(COM1)发送字符串 - :010100000010EE
                        //(COM1)收到字符串 - :0101024BF8B9

                        //:010102A44612\r\n

                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //byte[] byReadResultData = new byte[ReadDataLength];
                            //bool[] bReadResultData = new bool[ReadDataLength * 8];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 2, 2);//8 + i * 2, 2);
                            //    byReadResultData[i] = CConverter.TwoHexCharsToByte(sTemp);

                            //    bool[] bTemp = CConverter.ByteToBitArray(byReadResultData[i]);
                            //    for (int j = 0; j < bTemp.Length; j++)
                            //    {
                            //        bReadResultData[i * 8 + j] = bTemp[j];
                            //    }
                            //}

                            //BitValue = bReadResultData;

                            //string sSpliceResult = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 2);
                            //byte[] byHexStrToBytes = CConverter.Hex2StrTo1Byte(sSpliceResult);
                            //BitValue = CConverter.ByteToBitArray(byHexStrToBytes);

                            BitValue = CConverter.ByteToBitArray(CConverter.Hex2StrTo1Byte(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Byte)));
                            //BitValue = CConverter.ByteToBitArray(CConverter.Hex2StrTo1Byte(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 2)));

                            //bReadResultData = null;
                            //byReadResultData = null;

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站1个字节的线圈状态(1个字节 = 8位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ByteValue">返回线圈的1个字节当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilByte(byte DeviceAddress, ushort BeginAddress, ref byte ByteValue)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 1 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(1 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101FFFE

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :0101017F7E

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :0101017786

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //从站：10101010
                    //    //:   0  1  0  1  0  1  
                    //    //3A 30 31 30 31 30 31 41 41 35 33 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101AA53

                    //    //从站：10100010
                    //    //3A 30 31 30 31 30 31 41 32 35 42 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101A25B

                    //    //从站：11110010
                    //    //3A 30 31 30 31 30 31 46 32 30 42 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101F20B

                    //    //00000000
                    //    //成功执行读命令，结果值：False False False False False False False False 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :01010100FD

                    //    //11010001
                    //    //成功执行读命令，结果值：True True False True False False False True 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101D12C

                    //    //11011111
                    //    //成功执行读命令，结果值：True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101DF1E

                    //    //2个字节的通信记录
                    //    //0000000011011111
                    //    //成功执行读命令，结果值：False False False False False False False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DF001D

                    //    //1000010011011111
                    //    //成功执行读命令，结果值：True False False False False True False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DF8499

                    //    //1111010011011111
                    //    //成功执行读命令，结果值：True True True True False True False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DFF429

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 2);
                    //        ByteValue = CConverter.TwoHexCharsToByte(sTemp);                            

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"

                        //**********
                        //10100000
                        //成功执行读命令，结果值：False False False False False True False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101A05D

                        //***********
                        //11110000
                        //成功执行读命令，结果值：False False False False True True True True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101F00D

                        //***********
                        //10010011
                        //成功执行读命令，结果值：True True False False True False False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101936A

                        //成功执行读命令，结果值：False True False True False False False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :0101018A73

                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :01010159A4
                        //成功执行读命令，结果值：True False False True True False True False 

                        //成功执行读命令，结果值：True True False True False False True False False False False True False True False False 
                        //(COM1)发送字符串 - :010100000010EE
                        //(COM1)收到字符串 - :0101024B2889

                        //成功执行读命令，结果值：True True False True False False True False False False False True True True True True 
                        //(COM1)发送字符串 - :010100000010EE
                        //(COM1)收到字符串 - :0101024BF8B9

                        //:010102A44612\r\n

                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 2);
                            //ByteValue = CConverter.TwoHexCharsToByte(sTemp);

                            string sTemp = Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, (byte)HexStringCount.Byte);
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 2);
                            ByteValue = CConverter.TwoHexCharsToByte(sTemp);

                            sFeedBackFromSlave = null;
                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个字节的线圈状态(1个字节 = 位 - bit)，函数是以字节为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字节</param>
        /// <param name="ByteValue">返回线圈的字节当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilByte(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref byte[] ByteValue)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 250)//读取数据长度，有效值范围：1~250(字节)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~250(字节)");
                //}

                if (BeginAddress + ReadDataLength * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(ReadDataLength * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101FFFE

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :0101017F7E

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :0101017786

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //从站：10101010
                    //    //:   0  1  0  1  0  1  
                    //    //3A 30 31 30 31 30 31 41 41 35 33 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101AA53

                    //    //从站：10100010
                    //    //3A 30 31 30 31 30 31 41 32 35 42 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101A25B

                    //    //从站：11110010
                    //    //3A 30 31 30 31 30 31 46 32 30 42 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101F20B

                    //    //00000000
                    //    //成功执行读命令，结果值：False False False False False False False False 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :01010100FD

                    //    //11010001
                    //    //成功执行读命令，结果值：True True False True False False False True 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101D12C

                    //    //11011111
                    //    //成功执行读命令，结果值：True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101DF1E

                    //    //2个字节的通信记录
                    //    //0000000011011111
                    //    //成功执行读命令，结果值：False False False False False False False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DF001D

                    //    //1000010011011111
                    //    //成功执行读命令，结果值：True False False False False True False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DF8499

                    //    //1111010011011111
                    //    //成功执行读命令，结果值：True True True True False True False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DFF429

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        ByteValue = new byte[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 2, 2);
                    //            ByteValue[i] = CConverter.TwoHexCharsToByte(sTemp);
                    //        }

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"

                        //**********
                        //10100000
                        //成功执行读命令，结果值：False False False False False True False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101A05D

                        //***********
                        //11110000
                        //成功执行读命令，结果值：False False False False True True True True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101F00D

                        //***********
                        //10010011
                        //成功执行读命令，结果值：True True False False True False False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101936A

                        //成功执行读命令，结果值：False True False True False False False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :0101018A73

                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :01010159A4
                        //成功执行读命令，结果值：True False False True True False True False 

                        //成功执行读命令，结果值：True True False True False False True False False False False True False True False False 
                        //(COM1)发送字符串 - :010100000010EE
                        //(COM1)收到字符串 - :0101024B2889

                        //成功执行读命令，结果值：True True False True False False True False False False False True True True True True 
                        //(COM1)发送字符串 - :010100000010EE
                        //(COM1)收到字符串 - :0101024BF8B9

                        //:010102A44612\r\n

                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //ByteValue = new byte[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 2, 2);
                            //    ByteValue[i] = CConverter.TwoHexCharsToByte(sTemp);
                            //}

                            ByteValue = CConverter.Hex2StrTo1Byte(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Byte));
                            //ByteValue = CConverter.Hex2StrTo1Byte(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 2));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站1个字节的线圈状态(1个字节 = 8位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ByteValue">返回线圈的1个字节当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilByte(byte DeviceAddress, ushort BeginAddress, ref sbyte ByteValue)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 1 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(1 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 2);
                    //        ByteValue = (sbyte)CConverter.TwoHexCharsToByte(sTemp);                            

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"



                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 2);
                            //ByteValue = (sbyte)CConverter.TwoHexCharsToByte(sTemp);

                            string sTemp = Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, (byte)HexStringCount.SByte);
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 2);
                            ByteValue = (sbyte)CConverter.TwoHexCharsToByte(sTemp);

                            sFeedBackFromSlave = null;
                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个字节的线圈状态(1个字节 = 位 - bit)，函数是以字节为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字节</param>
        /// <param name="ByteValue">返回线圈的字节当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilByte(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref sbyte[] ByteValue)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 250)//读取数据长度，有效值范围：1~250(字节)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~250(字节)");
                //}

                if (BeginAddress + ReadDataLength * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(ReadDataLength * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        ByteValue = new sbyte[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 2, 2);
                    //            ByteValue[i] = (sbyte)CConverter.TwoHexCharsToByte(sTemp);
                    //        }

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"



                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            ByteValue = new sbyte[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 2, 2);
                            //    ByteValue[i] = (sbyte)CConverter.TwoHexCharsToByte(sTemp);
                            //}

                            byte[] byTemp = CConverter.Hex2StrTo1Byte(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.SByte));
                            //byte[] byTemp = CConverter.Hex2StrTo1Byte(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 2));
                            for (int i = 0; i < byTemp.Length; i++)
                            {
                                ByteValue[i] = (sbyte)byTemp[i];
                            }

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站1个字的线圈状态(位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回线圈的1个字当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilWord(byte DeviceAddress, ushort BeginAddress, ref short Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(2 * 8));//1个字 = 2 个字节 = 16位

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101FFFE

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :0101017F7E

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :0101017786

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //从站：10101010
                    //    //:   0  1  0  1  0  1  
                    //    //3A 30 31 30 31 30 31 41 41 35 33 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101AA53

                    //    //从站：10100010
                    //    //3A 30 31 30 31 30 31 41 32 35 42 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101A25B

                    //    //从站：11110010
                    //    //3A 30 31 30 31 30 31 46 32 30 42 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101F20B

                    //    //00000000
                    //    //成功执行读命令，结果值：False False False False False False False False 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :01010100FD

                    //    //11010001
                    //    //成功执行读命令，结果值：True True False True False False False True 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101D12C

                    //    //11011111
                    //    //成功执行读命令，结果值：True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101DF1E

                    //    //2个字节的通信记录
                    //    //0000000011011111
                    //    //成功执行读命令，结果值：False False False False False False False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DF001D

                    //    //1000010011011111
                    //    //成功执行读命令，结果值：True False False False False True False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DF8499

                    //    //1111010011011111
                    //    //成功执行读命令，结果值：True True True True False True False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DFF429

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);
                    //        sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                    //        int iValue = CConverter.HexStringToInt(sTemp);
                    //        byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                    //        Value = BitConverter.ToInt16(bytesOfInt, 0);

                    //        bytesOfInt = null;

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"

                        //**********
                        //10100000
                        //成功执行读命令，结果值：False False False False False True False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101A05D

                        //***********
                        //11110000
                        //成功执行读命令，结果值：False False False False True True True True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101F00D

                        //***********
                        //10010011
                        //成功执行读命令，结果值：True True False False True False False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101936A

                        //成功执行读命令，结果值：False True False True False False False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :0101018A73

                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :01010159A4
                        //成功执行读命令，结果值：True False False True True False True False 

                        //成功执行读命令，结果值：True True False True False False True False False False False True False True False False 
                        //(COM1)发送字符串 - :010100000010EE
                        //(COM1)收到字符串 - :0101024B2889

                        //成功执行读命令，结果值：True True False True False False True False False False False True True True True True 
                        //(COM1)发送字符串 - :010100000010EE
                        //(COM1)收到字符串 - :0101024BF8B9

                        //:010102A44612\r\n

                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);
                            //sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                            //int iValue = CConverter.HexStringToInt(sTemp);
                            //byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                            //Value = BitConverter.ToInt16(bytesOfInt, 0);

                            //string sSplice = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);
                            //byte[] byHex4StrTo2Bytes = CConverter.Hex4StrTo2Bytes(sSplice, ReadCoilBytesFormat);
                            //Value = CConverter.ToInt16(byHex4StrTo2Bytes);
                            Value = CConverter.ToInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, (byte)HexStringCount.Short), ReadCoilBytesFormat));
                            //Value = CConverter.ToInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4), ReadCoilBytesFormat));

                            //bytesOfInt = null;

                            sFeedBackFromSlave = null;
                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个字的线圈状态，函数是以字为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字</param>
        /// <param name="Value">返回线圈多个字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilWord(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref short[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~125(字)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 2 * 8 > 65535)//1个字 = 2 个字节 = 16位
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(ReadDataLength * 2 * 8));//1个字 = 2 个字节 = 16位

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101FFFE

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :0101017F7E

                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :0101017786

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //从站：10101010
                    //    //:   0  1  0  1  0  1  
                    //    //3A 30 31 30 31 30 31 41 41 35 33 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101AA53

                    //    //从站：10100010
                    //    //3A 30 31 30 31 30 31 41 32 35 42 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101A25B

                    //    //从站：11110010
                    //    //3A 30 31 30 31 30 31 46 32 30 42 0D 0A
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101F20B

                    //    //00000000
                    //    //成功执行读命令，结果值：False False False False False False False False 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :01010100FD

                    //    //11010001
                    //    //成功执行读命令，结果值：True True False True False False False True 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101D12C

                    //    //11011111
                    //    //成功执行读命令，结果值：True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000008F6
                    //    //(COM1)收到字符串 - :010101DF1E

                    //    //2个字节的通信记录
                    //    //0000000011011111
                    //    //成功执行读命令，结果值：False False False False False False False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DF001D

                    //    //1000010011011111
                    //    //成功执行读命令，结果值：True False False False False True False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DF8499

                    //    //1111010011011111
                    //    //成功执行读命令，结果值：True True True True False True False False True True False True True True True True 
                    //    //(COM1)发送字符串 - :010100000010EE
                    //    //(COM1)收到字符串 - :010102DFF429

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        short[] stResultValue = new short[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);
                    //            sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                    //            int iValue = CConverter.HexStringToInt(sTemp);
                    //            byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                    //            stResultValue[i] = BitConverter.ToInt16(bytesOfInt, 0);

                    //            bytesOfInt = null;
                    //        }

                    //        Value = stResultValue;
                    //        stResultValue = null;

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"

                        //**********
                        //10100000
                        //成功执行读命令，结果值：False False False False False True False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101A05D

                        //***********
                        //11110000
                        //成功执行读命令，结果值：False False False False True True True True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101F00D

                        //***********
                        //10010011
                        //成功执行读命令，结果值：True True False False True False False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :010101936A

                        //成功执行读命令，结果值：False True False True False False False True 
                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :0101018A73

                        //(COM1)发送字符串 - :010100000008F6
                        //(COM1)收到字符串 - :01010159A4
                        //成功执行读命令，结果值：True False False True True False True False 

                        //成功执行读命令，结果值：True True False True False False True False False False False True False True False False 
                        //(COM1)发送字符串 - :010100000010EE
                        //(COM1)收到字符串 - :0101024B2889

                        //成功执行读命令，结果值：True True False True False False True False False False False True True True True True 
                        //(COM1)发送字符串 - :010100000010EE
                        //(COM1)收到字符串 - :0101024BF8B9

                        //:010102A44612\r\n

                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //short[] stResultValue = new short[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);
                            //    sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                            //    int iValue = CConverter.HexStringToInt(sTemp);
                            //    byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                            //    stResultValue[i] = BitConverter.ToInt16(bytesOfInt, 0);

                            //    bytesOfInt = null;
                            //}

                            //Value = stResultValue;
                            //stResultValue = null;

                            Value = CConverter.ToInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Short), ReadCoilBytesFormat));
                            //Value = CConverter.ToInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 4), ReadCoilBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站1个字的线圈状态(位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回线圈的1个字当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilWord(byte DeviceAddress, ushort BeginAddress, ref ushort Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(2 * 8));//1个字 = 2 个字节 = 16位

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);
                    //        sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                    //        int iValue = CConverter.HexStringToInt(sTemp);
                    //        byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                    //        Value = BitConverter.ToUInt16(bytesOfInt, 0);

                    //        bytesOfInt = null;

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"

                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);
                            //sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                            //int iValue = CConverter.HexStringToInt(sTemp);
                            //byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                            //Value = BitConverter.ToUInt16(bytesOfInt, 0);

                            Value = CConverter.ToUInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, (byte)HexStringCount.UShort), ReadCoilBytesFormat));
                            //Value = CConverter.ToUInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4), ReadCoilBytesFormat));

                            //bytesOfInt = null;

                            sFeedBackFromSlave = null;
                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个字的线圈状态，函数是以字为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字</param>
        /// <param name="Value">返回线圈多个字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilWord(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref ushort[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~125(字)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 2 * 8 > 65535)//1个字 = 2 个字节 = 16位
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(ReadDataLength * 2 * 8));//1个字 = 2 个字节 = 16位

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        ushort[] stResultValue = new ushort[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);
                    //            sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                    //            int iValue = CConverter.HexStringToInt(sTemp);
                    //            byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                    //            stResultValue[i] = BitConverter.ToUInt16(bytesOfInt, 0);

                    //            bytesOfInt = null;
                    //        }

                    //        Value = stResultValue;
                    //        stResultValue = null;

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"


                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //ushort[] stResultValue = new ushort[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);
                            //    sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                            //    int iValue = CConverter.HexStringToInt(sTemp);
                            //    byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                            //    stResultValue[i] = BitConverter.ToUInt16(bytesOfInt, 0);

                            //    bytesOfInt = null;
                            //}

                            //Value = stResultValue;
                            //stResultValue = null;

                            Value = CConverter.ToUInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.UShort), ReadCoilBytesFormat));
                            //Value = CConverter.ToUInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 4), ReadCoilBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站1个双字的线圈状态(位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回线圈的1个双字当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilWord(byte DeviceAddress, ushort BeginAddress, ref int Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 4 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(4 * 8));//1个字 = 2 个字节 = 16位

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //这里是读取的字节结构：
                    //        //:010108 FFE36EC4 51F6540B 3C\r\n

                    //        //这里是在计算器里面转换的HEX字节结构：
                    //        //                 0B54F651
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);//‭10BC1B88‬  //‭‬

                    //        //读取的字节结构：2078B4EF
                    //        //转换的HEX字节结构：EFB47820

                    //        //读取的字节结构：FFE36EC4
                    //        //转换的HEX字节结构：C46EE3FF
                    //        string sResult = "";
                    //        for (int j = sTemp.Length / 2; j > 0; j--)
                    //        {
                    //            sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //        }

                    //        int iValue = CConverter.HexStringToInt(sResult);

                    //        Value = iValue;

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"

                        //成功执行写命令1214390746
                        //写操作记录：(COM1)发送字符串 - :010F0000002004DA21624827
                        //写操作记录：(COM1)收到字符串 - :010F00000020D0

                        //成功执行读命令，结果值：1214390746
                        //(COM1)发送字符串 - :010100000020DE
                        //(COM1)收到字符串 - :010104DA21624855

                        //成功执行写命令1175543634
                        //写操作记录：(COM1)发送字符串 - :010F0000002004525F1146C4
                        //写操作记录：(COM1)收到字符串 - :010F00000020D0

                        //成功执行读命令，结果值：1175543634
                        //(COM1)发送字符串 - :010100000020DE
                        //(COM1)收到字符串 - :010104525F1146F2

                        //成功执行写命令1930396067
                        //写操作记录：(COM1)发送字符串 - :010F0000002004A3810F7326
                        //写操作记录：(COM1)收到字符串 - :010F00000020D0

                        //成功执行读命令，结果值：1930396067
                        //(COM1)发送字符串 - :010100000020DE
                        //(COM1)收到字符串 - :010104A3810F7354

                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //这里是读取的字节结构：
                            //:010108 FFE36EC4 51F6540B 3C\r\n

                            //这里是在计算器里面转换的HEX字节结构：
                            //                 0B54F651
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);//‭10BC1B88‬  //‭‬

                            ////读取的字节结构：2078B4EF
                            ////转换的HEX字节结构：EFB47820

                            ////读取的字节结构：FFE36EC4
                            ////转换的HEX字节结构：C46EE3FF
                            //string sResult = "";
                            //for (int j = sTemp.Length / 2; j > 0; j--)
                            //{
                            //    sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //}

                            //int iValue = CConverter.HexStringToInt(sResult);

                            //Value = iValue;

                            Value = CConverter.ToInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.Int), ReadCoilBytesFormat));
                            //Value = CConverter.ToInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 8), ReadCoilBytesFormat));

                            sFeedBackFromSlave = null;
                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个双字的线圈状态，函数是以字为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字</param>
        /// <param name="Value">返回线圈多个双字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilWord(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref int[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~125(字)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 4 * 8 > 65535)//1个字 = 2 个字节 = 16位
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(ReadDataLength * 4 * 8));//1个字 = 2 个字节 = 16位

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //发送值[0~1]：1099526371 1920016278
                //写操作记录：(COM1)发送字符串 - :010F0000004008E3708941961F7172F3
                //写操作记录：(COM1)收到字符串 - :010F00000040B0

                //成功执行读命令，结果值：1099526371 1920016278 
                //(COM1)发送字符串 - :010100000040BE
                //(COM1)收到字符串 - :010108E3708941961F717241

                //发送值[0~1]：1254912609 98040679
                //写操作记录：(COM1)发送字符串 - :010F00000040086172CC4A67FBD70581
                //写操作记录：(COM1)收到字符串 - :010F00000040B0

                //成功执行读命令，结果值：1254912609 98040679 
                //(COM1)发送字符串 - :010100000040BE
                //(COM1)收到字符串 - :0101086172CC4A67FBD705CF

                //成功执行读命令，结果值：1254912609 98040679 
                //(COM1)发送字符串 - :010100000040BE
                //(COM1)收到字符串 - :0101086172CC4A67FBD705CF

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //     if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        int[] iResult = new int[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //这里是读取的字节结构：
                    //            //:010108 FFE36EC4 51F6540B 3C\r\n

                    //            //这里是在计算器里面转换的HEX字节结构：
                    //            //                 0B54F651
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);//‭10BC1B88‬  //‭‬

                    //            //读取的字节结构：2078B4EF
                    //            //转换的HEX字节结构：EFB47820

                    //            //读取的字节结构：FFE36EC4
                    //            //转换的HEX字节结构：C46EE3FF
                    //            string sResult = "";
                    //            for (int j = sTemp.Length / 2; j > 0 ; j--)
                    //            {
                    //                sResult += Strings.Mid(sTemp,  j * 2 - 1, 2);
                    //            }

                    //            iResult[i] = CConverter.HexStringToInt(sResult);
                    //        }

                    //        Value = iResult;
                    //        iResult = null;

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //int[] iResult = new int[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //这里是读取的字节结构：
                            //    //:010108 FFE36EC4 51F6540B 3C\r\n

                            //    //这里是在计算器里面转换的HEX字节结构：
                            //    //                 0B54F651
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);//‭10BC1B88‬  //‭‬

                            //    //读取的字节结构：2078B4EF
                            //    //转换的HEX字节结构：EFB47820

                            //    //读取的字节结构：FFE36EC4
                            //    //转换的HEX字节结构：C46EE3FF
                            //    string sResult = "";
                            //    for (int j = sTemp.Length / 2; j > 0; j--)
                            //    {
                            //        sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //    }

                            //    iResult[i] = CConverter.HexStringToInt(sResult);
                            //}

                            //Value = iResult;
                            //iResult = null;

                            Value = CConverter.ToInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Int), ReadCoilBytesFormat));
                            //Value = CConverter.ToInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 8), ReadCoilBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站1个双字的线圈状态(位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回线圈的1个双字当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilWord(byte DeviceAddress, ushort BeginAddress, ref uint Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 4 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(4 * 8));//1个字 = 2 个字节 = 16位

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //这里是读取的字节结构：
                    //        //:010108 FFE36EC4 51F6540B 3C\r\n

                    //        //这里是在计算器里面转换的HEX字节结构：
                    //        //                 0B54F651
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);//‭10BC1B88‬  //‭‬

                    //        //读取的字节结构：2078B4EF
                    //        //转换的HEX字节结构：EFB47820

                    //        //读取的字节结构：FFE36EC4
                    //        //转换的HEX字节结构：C46EE3FF
                    //        string sResult = "";
                    //        for (int j = sTemp.Length / 2; j > 0; j--)
                    //        {
                    //            sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //        }

                    //        uint iValue = (uint)CConverter.HexStringToInt(sResult);

                    //        Value = iValue;

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"


                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            ////这里是读取的字节结构：
                            ////:010108 FFE36EC4 51F6540B 3C\r\n

                            ////这里是在计算器里面转换的HEX字节结构：
                            ////                 0B54F651
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);//‭10BC1B88‬  //‭‬

                            ////读取的字节结构：2078B4EF
                            ////转换的HEX字节结构：EFB47820

                            ////读取的字节结构：FFE36EC4
                            ////转换的HEX字节结构：C46EE3FF
                            //string sResult = "";
                            //for (int j = sTemp.Length / 2; j > 0; j--)
                            //{
                            //    sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //}

                            //uint iValue = (uint)CConverter.HexStringToInt(sResult);

                            //Value = iValue;

                            Value = CConverter.ToUInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.UInt), ReadCoilBytesFormat));
                            //Value = CConverter.ToUInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 8), ReadCoilBytesFormat));

                            sFeedBackFromSlave = null;
                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个双字的线圈状态，函数是以字为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字</param>
        /// <param name="Value">返回线圈多个双字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilWord(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref uint[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~125(字)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 4 * 8 > 65535)//1个字 = 2 个字节 = 16位
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(ReadDataLength * 4 * 8));//1个字 = 2 个字节 = 16位

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"


                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //     if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        uint[] iResult = new uint[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //这里是读取的字节结构：
                    //            //:010108 FFE36EC4 51F6540B 3C\r\n

                    //            //这里是在计算器里面转换的HEX字节结构：
                    //            //                 0B54F651
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);//‭10BC1B88‬  //‭‬

                    //            //读取的字节结构：2078B4EF
                    //            //转换的HEX字节结构：EFB47820

                    //            //读取的字节结构：FFE36EC4
                    //            //转换的HEX字节结构：C46EE3FF
                    //            string sResult = "";
                    //            for (int j = sTemp.Length / 2; j > 0 ; j--)
                    //            {
                    //                sResult += Strings.Mid(sTemp,  j * 2 - 1, 2);
                    //            }

                    //            iResult[i] = (uint)CConverter.HexStringToInt(sResult);
                    //        }

                    //        Value = iResult;
                    //        iResult = null;

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //uint[] iResult = new uint[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //这里是读取的字节结构：
                            //    //:010108 FFE36EC4 51F6540B 3C\r\n

                            //    //这里是在计算器里面转换的HEX字节结构：
                            //    //                 0B54F651
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);//‭10BC1B88‬  //‭‬

                            //    //读取的字节结构：2078B4EF
                            //    //转换的HEX字节结构：EFB47820

                            //    //读取的字节结构：FFE36EC4
                            //    //转换的HEX字节结构：C46EE3FF
                            //    string sResult = "";
                            //    for (int j = sTemp.Length / 2; j > 0; j--)
                            //    {
                            //        sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //    }

                            //    iResult[i] = (uint)CConverter.HexStringToInt(sResult);
                            //}

                            //Value = iResult;
                            //iResult = null;

                            Value = CConverter.ToUInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.UInt), ReadCoilBytesFormat));
                            //Value = CConverter.ToUInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 8), ReadCoilBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站2个双字的线圈状态(位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回线圈的2个双字当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilWord(byte DeviceAddress, ushort BeginAddress, ref long Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 8 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(8 * 8));//1个字 = 2 个字节 = 16位

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 1

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //成功执行写命令-790511038
                //写操作记录：(COM1)发送字符串 - :010F000000400842C2E1D0FFFFFFFFF7
                //写操作记录：(COM1)收到字符串 - :010F00000040B0

                //成功执行读命令，结果值：-790511038
                //(COM1)发送字符串 - :010100000040BE
                //(COM1)收到字符串 - :01010842C2E1D0FFFFFFFF45

                //成功执行读命令，结果值：-790511038
                //(COM1)发送字符串 - :010100000040BE
                //(COM1)收到字符串 - :01010842C2E1D0FFFFFFFF45

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //这里是读取的字节结构：
                    //        //:0101087BCF1680FFFFFFFF1A\r\n
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                    //        //读取的字节结构：7BCF1680FFFFFFFF
                    //        //转换的HEX字节结构：FFFFFFFF8016CF7B
                    //        string sResult = "";
                    //        for (int j = sTemp.Length / 2; j > 0; j--)
                    //        {
                    //            sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //        }

                    //        long lValue = CConverter.HexStringToLong(sResult);

                    //        Value = lValue;

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"



                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            ////这里是读取的字节结构：
                            ////:0101087BCF1680FFFFFFFF1A\r\n
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                            ////读取的字节结构：7BCF1680FFFFFFFF
                            ////转换的HEX字节结构：FFFFFFFF8016CF7B
                            //string sResult = "";
                            //for (int j = sTemp.Length / 2; j > 0; j--)
                            //{
                            //    sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //}

                            //long lValue = CConverter.HexStringToLong(sResult);

                            //Value = lValue;

                            Value = CConverter.ToInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.Long), ReadCoilBytesFormat));
                            //Value = CConverter.ToInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 16), ReadCoilBytesFormat));

                            sFeedBackFromSlave = null;
                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站N个2个双字的线圈状态，函数是以字为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字</param>
        /// <param name="Value">返回线圈N个2个双字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilWord(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref long[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~125(字)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 8 * 8 > 65535)//1个字 = 2 个字节 = 16位
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(ReadDataLength * 8 * 8));//1个字 = 2 个字节 = 16位

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 1

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //发送值[0~1]：1325802384 1140179960 
                //成功执行写命令
                //写操作记录：(COM1)发送字符串 - :010F00000080109023064F00000000F8C3F5430000000065
                //写操作记录：(COM1)收到字符串 - :010F0000008070

                //成功执行读命令，结果值：1325802384 1140179960 
                //(COM1)发送字符串 - :0101000000807E
                //(COM1)收到字符串 - :0101109023064F00000000F8C3F54300000000F3

                //发送值[0~1]：-1278254254 1513776700
                //写操作记录：(COM1)发送字符串 - :010F00000080105263CFB3FFFFFFFF3C663A5A00000000F7
                //写操作记录：(COM1)收到字符串 - :010F0000008070

                //成功执行读命令，结果值：-1278254254 1513776700 
                //(COM1)发送字符串 - :0101000000807E
                //(COM1)收到字符串 - :0101105263CFB3FFFFFFFF3C663A5A0000000085

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        long[] lResultData = new long[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //这里是读取的字节结构：
                    //            //:0101087BCF1680FFFFFFFF1A\r\n
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                    //            //读取的字节结构：7BCF1680FFFFFFFF
                    //            //转换的HEX字节结构：FFFFFFFF8016CF7B
                    //            string sResult = "";
                    //            for (int j = sTemp.Length / 2; j > 0; j--)
                    //            {
                    //                sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //            }

                    //            long lValue = CConverter.HexStringToLong(sResult);
                    //            lResultData[i] = lValue;
                    //        }

                    //        Value = lResultData;
                    //        lResultData = null;

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"



                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //long[] lResultData = new long[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //这里是读取的字节结构：
                            //    //:0101087BCF1680FFFFFFFF1A\r\n
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                            //    //读取的字节结构：7BCF1680FFFFFFFF
                            //    //转换的HEX字节结构：FFFFFFFF8016CF7B
                            //    string sResult = "";
                            //    for (int j = sTemp.Length / 2; j > 0; j--)
                            //    {
                            //        sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //    }

                            //    long lValue = CConverter.HexStringToLong(sResult);
                            //    lResultData[i] = lValue;
                            //}

                            //Value = lResultData;
                            //lResultData = null;

                            Value = CConverter.ToInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Long), ReadCoilBytesFormat));
                            //Value = CConverter.ToInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 16), ReadCoilBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站2个双字的线圈状态(位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回线圈的2个双字当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilWord(byte DeviceAddress, ushort BeginAddress, ref ulong Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 8 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(8 * 8));//1个字 = 2 个字节 = 16位

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 1

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************


                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //这里是读取的字节结构：
                    //        //:0101087BCF1680FFFFFFFF1A\r\n
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                    //        //读取的字节结构：7BCF1680FFFFFFFF
                    //        //转换的HEX字节结构：FFFFFFFF8016CF7B
                    //        string sResult = "";
                    //        for (int j = sTemp.Length / 2; j > 0; j--)
                    //        {
                    //            sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //        }

                    //        ulong lValue = (ulong)CConverter.HexStringToLong(sResult);

                    //        Value = lValue;

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"



                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            ////这里是读取的字节结构：
                            ////:0101087BCF1680FFFFFFFF1A\r\n
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                            ////读取的字节结构：7BCF1680FFFFFFFF
                            ////转换的HEX字节结构：FFFFFFFF8016CF7B
                            //string sResult = "";
                            //for (int j = sTemp.Length / 2; j > 0; j--)
                            //{
                            //    sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //}

                            //ulong lValue = (ulong)CConverter.HexStringToLong(sResult);

                            //Value = lValue;

                            Value = CConverter.ToUInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.ULong), ReadCoilBytesFormat));
                            //Value = CConverter.ToUInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 16), ReadCoilBytesFormat));

                            sFeedBackFromSlave = null;
                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站N个2个双字的线圈状态，函数是以字为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字</param>
        /// <param name="Value">返回线圈N个2个双字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadCoilWord(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref ulong[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~125(字)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 8 * 8 > 65535)//1个字 = 2 个字节 = 16位
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadCoil, BeginAddress, Convert.ToUInt16(ReadDataLength * 8 * 8));//1个字 = 2 个字节 = 16位

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 1

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************


                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 1

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    string sCmd = ModbusFuncCode.ReadCoil.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadCoil.ToString()[0])//:0101
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        ulong[] lResultData = new ulong[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //这里是读取的字节结构：
                    //            //:0101087BCF1680FFFFFFFF1A\r\n
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                    //            //读取的字节结构：7BCF1680FFFFFFFF
                    //            //转换的HEX字节结构：FFFFFFFF8016CF7B
                    //            string sResult = "";
                    //            for (int j = sTemp.Length / 2; j > 0; j--)
                    //            {
                    //                sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //            }

                    //            ulong lValue = (ulong)CConverter.HexStringToLong(sResult);
                    //            lResultData[i] = lValue;
                    //        }

                    //        Value = lResultData;
                    //        lResultData = null;

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //    //byReadData = null;
                    //        sFeedBackFromSlave = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"



                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadCoil.ToString("X2"))//"01"
                        {
                            //ulong[] lResultData = new ulong[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //这里是读取的字节结构：
                            //    //:0101087BCF1680FFFFFFFF1A\r\n
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                            //    //读取的字节结构：7BCF1680FFFFFFFF
                            //    //转换的HEX字节结构：FFFFFFFF8016CF7B
                            //    string sResult = "";
                            //    for (int j = sTemp.Length / 2; j > 0; j--)
                            //    {
                            //        sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //    }

                            //    ulong lValue = (ulong)CConverter.HexStringToLong(sResult);
                            //    lResultData[i] = lValue;
                            //}

                            //Value = lResultData;
                            //lResultData = null;

                            Value = CConverter.ToUInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.ULong), ReadCoilBytesFormat));
                            //Value = CConverter.ToUInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 16), ReadCoilBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        #endregion

        #region "读单个/多个输入位的状态 - ok-ok"

        // ok-ok
        /// <summary>
        /// 读取从站单个输入位的状态(位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回单个输入位的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputBit(byte DeviceAddress, ushort BeginAddress, ref bool Value)//ushort ReadDataLength 读取数据长度,   , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节

                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, 1);//ReadDataLength

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //成功执行读命令，结果值：True
                //(COM1)发送字符串 - :010200000001FC
                //(COM1)收到字符串 - :01020101FB

                //成功执行读命令，结果值：False
                //(COM1)发送字符串 - :010200000001FC
                //(COM1)收到字符串 - :01020100FC

                //成功执行读命令，结果值：False
                //(COM1)发送字符串 - :010200000001FC
                //(COM1)收到字符串 - :01020100FC

                //成功执行读命令，结果值：True
                //(COM1)发送字符串 - :010200000001FC
                //(COM1)收到字符串 - :01020101FB

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 2

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //***********Inputsignal
                    //    //:01020101FB\r\n
                    //    //成功执行读命令，结果值：True
                    //    //(COM1)发送字符串 - :010200000001FC
                    //    //(COM1)收到字符串 - :01020101FB

                    //    //:01020100FC\r\n
                    //    //成功执行读命令，结果值：False
                    //    //(COM1)发送字符串 - :010200000001FC
                    //    //(COM1)收到字符串 - :01020100FC

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputSignal.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //读取成功
                    //        if (Strings.Mid(sFeedBackFromSlave, 9, 1) == "0")
                    //        {
                    //            //读取的值是0
                    //            Value = false;
                    //        }
                    //        else
                    //        {
                    //            //读取的值是1
                    //            Value = true;
                    //        }

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"

                        //**********************
                        //首字符
                        //[0] - :

                        //从站地址
                        //[1] - 0
                        //[2] - 1

                        //读取成功的功能码
                        //[3] - 0
                        //[4] - 2

                        //读取失败的错误码
                        //[3] - 0
                        //[4] - 8
                        //**********************

                        //:01020100FC\r\n
                        //成功执行读命令，结果值：False
                        //(COM1)发送字符串 - :010200000001FC
                        //(COM1)收到字符串 - :01020100FC

                        //:01020101FB\r\n
                        //成功执行读命令，结果值：True
                        //(COM1)发送字符串 - :010200000001FC
                        //(COM1)收到字符串 - :01020101FB

                        #endregion

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            //读取成功
                            if (Strings.Mid(sFeedBackFromSlave, 9, 1) == "0")
                            {
                                //读取的值是0
                                Value = false;
                            }
                            else
                            {
                                //读取的值是1
                                Value = true;
                            }

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            //读取错误
                            //throw new Exception("");
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个字节的输入状态(1个字节 = 8位 - bit)，函数是以字节为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字节</param>
        /// <param name="Value">返回多个字节输入状态的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputBit(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref bool[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~250(字节)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~250(字节)");
                //}

                if (BeginAddress + ReadDataLength * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(ReadDataLength * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //成功执行读命令，结果值：True False False False False False False False False False False False False False False False 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :0102020100FA

                //成功执行读命令，结果值：True True True True False False False False False False False False False False False False 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :0102020F00EC

                //成功执行读命令，结果值：True True True True False False True True False False True True False False True True 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :010202CFCC60

                //成功执行读命令，结果值：True True True True False False True True False False True True False False True True 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :010202CFCC60

                //成功执行读命令，结果值：True True True True False False True True False False True True False False True True 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :010202CFCC60

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        byte[] byReadResultData = new byte[ReadDataLength];
                    //        //bool[] bReadResultData = new bool[ReadDataLength * 8];
                    //        Value = new bool[ReadDataLength * 8];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 2, 2);
                    //            byReadResultData[i] = CConverter.TwoHexCharsToByte(sTemp);

                    //            bool[] bTemp = CConverter.ByteToBitArray(byReadResultData[i]);
                    //            for (int j = 0; j < bTemp.Length; j++)
                    //            {
                    //                Value[i * 8 + j] = bTemp[j];//bReadResultData
                    //            }
                    //        }

                    //        //BitValue = bReadResultData;

                    //        //bReadResultData = null;
                    //        byReadResultData = null;

                    //        //BitValue = bReadResultData;

                    //        //bReadResultData = null;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            //byte[] byReadResultData = new byte[ReadDataLength];
                            //bool[] bReadResultData = new bool[ReadDataLength * 8];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 2, 2);
                            //    byReadResultData[i] = CConverter.TwoHexCharsToByte(sTemp);

                            //    bool[] bTemp = CConverter.ByteToBitArray(byReadResultData[i]);
                            //    for (int j = 0; j < bTemp.Length; j++)
                            //    {
                            //        bReadResultData[i * 8 + j] = bTemp[j];
                            //    }
                            //}

                            //Value = bReadResultData;
                            //bReadResultData = null;

                            Value = CConverter.ByteToBitArray(CConverter.Hex2StrTo1Byte(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Byte)));
                            //Value = CConverter.ByteToBitArray(CConverter.Hex2StrTo1Byte(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 2)));

                            //byReadResultData = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站1个字节的输入状态(1个字节 = 8位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入状态1个字节的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputByte(byte DeviceAddress, ushort BeginAddress, ref byte Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 1 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(1 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //成功执行读命令，结果值：True False False False False False False False False False False False False False False False 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :0102020100FA

                //成功执行读命令，结果值：True True True True False False False False False False False False False False False False 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :0102020F00EC

                //成功执行读命令，结果值：True True True True False False True True False False True True False False True True 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :010202CFCC60

                //成功执行读命令，结果值：True True True True False False True True False False True True False False True True 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :010202CFCC60

                //成功执行读命令，结果值：True True True True False False True True False False True True False False True True 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :010202CFCC60

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 2);
                    //        Value = CConverter.TwoHexCharsToByte(sTemp);

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            string sTemp = Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, (byte)HexStringCount.Byte);
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 2);
                            Value = CConverter.TwoHexCharsToByte(sTemp);

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个字节的输入状态(1个字节 = 8位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字节</param>
        /// <param name="Value">返回输入状态多个字节的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputByte(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref byte[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~250(字节)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~250(字节)");
                //}

                if (BeginAddress + ReadDataLength * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(ReadDataLength * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //成功执行读命令，结果值：True False False False False False False False False False False False False False False False 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :0102020100FA

                //成功执行读命令，结果值：True True True True False False False False False False False False False False False False 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :0102020F00EC

                //成功执行读命令，结果值：True True True True False False True True False False True True False False True True 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :010202CFCC60

                //成功执行读命令，结果值：True True True True False False True True False False True True False False True True 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :010202CFCC60

                //成功执行读命令，结果值：True True True True False False True True False False True True False False True True 
                //(COM1)发送字符串 - :010200000010ED
                //(COM1)收到字符串 - :010202CFCC60

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        Value = new byte[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 2, 2);
                    //            Value[i] = CConverter.TwoHexCharsToByte(sTemp);
                    //        }

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            //Value = new byte[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 2, 2);
                            //    Value[i] = CConverter.TwoHexCharsToByte(sTemp);
                            //}

                            Value = CConverter.Hex2StrTo1Byte(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Byte));
                            //Value = CConverter.Hex2StrTo1Byte(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 2));

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站1个字节的输入状态(1个字节 = 8位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入状态1个字节的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputByte(byte DeviceAddress, ushort BeginAddress, ref sbyte Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 1 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(1 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 2);
                    //        Value = (sbyte)CConverter.TwoHexCharsToByte(sTemp);

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            string sTemp = Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, (byte)HexStringCount.Byte);
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 2);
                            Value = (sbyte)CConverter.TwoHexCharsToByte(sTemp);

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个字节的输入状态(1个字节 = 8位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字节</param>
        /// <param name="Value">返回输入状态多个字节的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputByte(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref sbyte[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~250(字节)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~250(字节)");
                //}

                if (BeginAddress + ReadDataLength * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(ReadDataLength * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        Value = new sbyte[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 2, 2);
                    //            Value[i] = (sbyte)CConverter.TwoHexCharsToByte(sTemp);
                    //        }

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            Value = new sbyte[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 2, 2);
                            //    Value[i] = (sbyte)CConverter.TwoHexCharsToByte(sTemp);
                            //}

                            byte[] byTemp = CConverter.Hex2StrTo1Byte(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Byte));
                            //byte[] byTemp = CConverter.Hex2StrTo1Byte(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 2));
                            for (int i = 0; i < byTemp.Length; i++)
                            {
                                Value[i] = (sbyte)byTemp[i];
                            }

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站1个字的输入状态
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入状态1个字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputWord(byte DeviceAddress, ushort BeginAddress, ref short Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(2 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //在写操作里面

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);

                    //        sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                    //        int iValue = CConverter.HexStringToInt(sTemp);
                    //        byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                    //        Value = BitConverter.ToInt16(bytesOfInt, 0);

                    //        bytesOfInt = null;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);

                            //sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                            //int iValue = CConverter.HexStringToInt(sTemp);
                            //byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                            //Value = BitConverter.ToInt16(bytesOfInt, 0);

                            //string sSplice = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);

                            Value = CConverter.ToInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, (byte)HexStringCount.Short), ReadInputIOBytesFormat));
                            //Value = CConverter.ToInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4), ReadInputIOBytesFormat));

                            //bytesOfInt = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个字的输入状态
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字</param>
        /// <param name="Value">返回输入状态多个字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputWord(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref short[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(ReadDataLength * 2 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //在写操作里面

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        short[] stResultValue = new short[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);

                    //            sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                    //            int iValue = CConverter.HexStringToInt(sTemp);
                    //            byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                    //            stResultValue[i] = BitConverter.ToInt16(bytesOfInt, 0);

                    //            bytesOfInt = null;

                    //            bytesOfInt = null;
                    //        }

                    //        Value = stResultValue;
                    //        stResultValue = null;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            //short[] stResultValue = new short[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);

                            //    sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                            //    int iValue = CConverter.HexStringToInt(sTemp);
                            //    byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                            //    stResultValue[i] = BitConverter.ToInt16(bytesOfInt, 0);

                            //    bytesOfInt = null;
                            //}

                            //Value = stResultValue;
                            //stResultValue = null;

                            Value = CConverter.ToInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Short), ReadInputIOBytesFormat));
                            //Value = CConverter.ToInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 4), ReadInputIOBytesFormat));

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站1个字的输入状态
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入状态1个字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputWord(byte DeviceAddress, ushort BeginAddress, ref ushort Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(2 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //在写操作里面

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);

                    //        sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                    //        int iValue = CConverter.HexStringToInt(sTemp);
                    //        byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                    //        Value = BitConverter.ToUInt16(bytesOfInt, 0);

                    //        bytesOfInt = null;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);

                            //sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                            //int iValue = CConverter.HexStringToInt(sTemp);
                            //byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                            //Value = BitConverter.ToUInt16(bytesOfInt, 0);

                            Value = CConverter.ToUInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, (byte)HexStringCount.UShort), ReadInputIOBytesFormat));
                            //Value = CConverter.ToUInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4), ReadInputIOBytesFormat));

                            //bytesOfInt = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个字的输入状态
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字</param>
        /// <param name="Value">返回输入状态多个字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputWord(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref ushort[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(ReadDataLength * 2 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //在写操作里面

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        ushort[] stResultValue = new ushort[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);

                    //            sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                    //            int iValue = CConverter.HexStringToInt(sTemp);
                    //            byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                    //            stResultValue[i] = BitConverter.ToUInt16(bytesOfInt, 0);

                    //            bytesOfInt = null;

                    //            bytesOfInt = null;
                    //        }

                    //        Value = stResultValue;
                    //        stResultValue = null;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            //ushort[] stResultValue = new ushort[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);

                            //    sTemp = Strings.Mid(sTemp, 3, 2) + Strings.Mid(sTemp, 1, 2);//高低字节互换：D67C --> 7CD6

                            //    int iValue = CConverter.HexStringToInt(sTemp);
                            //    byte[] bytesOfInt = BitConverter.GetBytes(iValue);
                            //    stResultValue[i] = BitConverter.ToUInt16(bytesOfInt, 0);

                            //    bytesOfInt = null;
                            //}

                            //Value = stResultValue;
                            //stResultValue = null;

                            Value = CConverter.ToUInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.UShort), ReadInputIOBytesFormat));
                            //Value = CConverter.ToUInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 4), ReadInputIOBytesFormat));

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站1个双字的输入状态
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入状态1个双字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputWord(byte DeviceAddress, ushort BeginAddress, ref int Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 4 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(4 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //在写操作里面

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //这里是读取的字节结构：
                    //        //:010108 FFE36EC4 51F6540B 3C\r\n

                    //        //这里是在计算器里面转换的HEX字节结构：
                    //        //                 0B54F651
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);//‭10BC1B88‬  //‭‬

                    //        //读取的字节结构：2078B4EF
                    //        //转换的HEX字节结构：EFB47820

                    //        //读取的字节结构：FFE36EC4
                    //        //转换的HEX字节结构：C46EE3FF
                    //        string sResult = "";
                    //        for (int j = sTemp.Length / 2; j > 0; j--)
                    //        {
                    //            sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //        }

                    //        int iValue = CConverter.HexStringToInt(sResult);

                    //        Value = iValue;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            ////这里是读取的字节结构：
                            ////:010108 FFE36EC4 51F6540B 3C\r\n

                            ////这里是在计算器里面转换的HEX字节结构：
                            ////                 0B54F651
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);//‭10BC1B88‬  //‭‬

                            ////读取的字节结构：2078B4EF
                            ////转换的HEX字节结构：EFB47820

                            ////读取的字节结构：FFE36EC4
                            ////转换的HEX字节结构：C46EE3FF
                            //string sResult = "";
                            //for (int j = sTemp.Length / 2; j > 0; j--)
                            //{
                            //    sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //}

                            //int iValue = CConverter.HexStringToInt(sResult);

                            //Value = iValue;

                            Value = CConverter.ToInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, (byte)HexStringCount.Int), ReadInputIOBytesFormat));
                            //Value = CConverter.ToInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8), ReadInputIOBytesFormat));

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个双字的输入状态
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字</param>
        /// <param name="Value">返回输入状态多个双字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputWord(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref int[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 4 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(ReadDataLength * 4 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //在写操作里面

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        int[] iResultValue = new int[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //这里是读取的字节结构：
                    //            //:010108 FFE36EC4 51F6540B 3C\r\n

                    //            //这里是在计算器里面转换的HEX字节结构：
                    //            //                 0B54F651
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);//‭10BC1B88‬  //‭‬

                    //            //读取的字节结构：2078B4EF
                    //            //转换的HEX字节结构：EFB47820

                    //            //读取的字节结构：FFE36EC4
                    //            //转换的HEX字节结构：C46EE3FF
                    //            string sResult = "";
                    //            for (int j = sTemp.Length / 2; j > 0; j--)
                    //            {
                    //                sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //            }

                    //            iResultValue[i] = (int)CConverter.HexStringToLong(sResult);
                    //        }

                    //        Value = iResultValue;
                    //        iResultValue = null;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            //int[] iResultValue = new int[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);

                            //    //这里是读取的字节结构：
                            //    //:010108 FFE36EC4 51F6540B 3C\r\n

                            //    //这里是在计算器里面转换的HEX字节结构：
                            //    //                 0B54F651

                            //    //读取的字节结构：2078B4EF
                            //    //转换的HEX字节结构：EFB47820

                            //    //读取的字节结构：FFE36EC4
                            //    //转换的HEX字节结构：C46EE3FF
                            //    string sResult = "";
                            //    for (int j = sTemp.Length / 2; j > 0; j--)
                            //    {
                            //        sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //    }

                            //    iResultValue[i] = (int)CConverter.HexStringToLong(sResult);
                            //}

                            //Value = iResultValue;
                            //iResultValue = null;

                            Value = CConverter.ToInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Int), ReadInputIOBytesFormat));
                            //Value = CConverter.ToInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 8), ReadInputIOBytesFormat));

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站1个双字的输入状态
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入状态1个双字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputWord(byte DeviceAddress, ushort BeginAddress, ref uint Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 4 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(4 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //在写操作里面

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //这里是读取的字节结构：
                    //        //:010108 FFE36EC4 51F6540B 3C\r\n

                    //        //这里是在计算器里面转换的HEX字节结构：
                    //        //                 0B54F651
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);//‭10BC1B88‬  //‭‬

                    //        //读取的字节结构：2078B4EF
                    //        //转换的HEX字节结构：EFB47820

                    //        //读取的字节结构：FFE36EC4
                    //        //转换的HEX字节结构：C46EE3FF
                    //        string sResult = "";
                    //        for (int j = sTemp.Length / 2; j > 0; j--)
                    //        {
                    //            sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //        }

                    //        uint iValue = (uint)CConverter.HexStringToInt(sResult);

                    //        Value = iValue;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            ////这里是读取的字节结构：
                            ////:010108 FFE36EC4 51F6540B 3C\r\n

                            ////这里是在计算器里面转换的HEX字节结构：
                            ////                 0B54F651
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);//‭10BC1B88‬  //‭‬

                            ////读取的字节结构：2078B4EF
                            ////转换的HEX字节结构：EFB47820

                            ////读取的字节结构：FFE36EC4
                            ////转换的HEX字节结构：C46EE3FF
                            //string sResult = "";
                            //for (int j = sTemp.Length / 2; j > 0; j--)
                            //{
                            //    sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //}

                            //uint iValue = (uint)CConverter.HexStringToInt(sResult);

                            //Value = iValue;

                            Value = CConverter.ToUInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.UInt), ReadInputIOBytesFormat));
                            //Value = CConverter.ToUInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 8), ReadInputIOBytesFormat));

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个双字的输入状态
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字</param>
        /// <param name="Value">返回输入状态多个双字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputWord(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref uint[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 4 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(ReadDataLength * 4 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //在写操作里面

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        uint[] iResultValue = new uint[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //这里是读取的字节结构：
                    //            //:010108 FFE36EC4 51F6540B 3C\r\n

                    //            //这里是在计算器里面转换的HEX字节结构：
                    //            //                 0B54F651
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);//‭10BC1B88‬  //‭‬

                    //            //读取的字节结构：2078B4EF
                    //            //转换的HEX字节结构：EFB47820

                    //            //读取的字节结构：FFE36EC4
                    //            //转换的HEX字节结构：C46EE3FF
                    //            string sResult = "";
                    //            for (int j = sTemp.Length / 2; j > 0; j--)
                    //            {
                    //                sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //            }

                    //            iResultValue[i] = (uint)CConverter.HexStringToLong(sResult);
                    //        }

                    //        Value = iResultValue;
                    //        iResultValue = null;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            //uint[] iResultValue = new uint[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);

                            //    //这里是读取的字节结构：
                            //    //:010108 FFE36EC4 51F6540B 3C\r\n

                            //    //这里是在计算器里面转换的HEX字节结构：
                            //    //                 0B54F651

                            //    //读取的字节结构：2078B4EF
                            //    //转换的HEX字节结构：EFB47820

                            //    //读取的字节结构：FFE36EC4
                            //    //转换的HEX字节结构：C46EE3FF
                            //    string sResult = "";
                            //    for (int j = sTemp.Length / 2; j > 0; j--)
                            //    {
                            //        sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //    }

                            //    iResultValue[i] = (uint)CConverter.HexStringToLong(sResult);
                            //}

                            //Value = iResultValue;
                            //iResultValue = null;

                            Value = CConverter.ToUInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.UInt), ReadInputIOBytesFormat));
                            //Value = CConverter.ToUInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 8), ReadInputIOBytesFormat));

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站2个双字的输入状态
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入状态2个双字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputWord(byte DeviceAddress, ushort BeginAddress, ref long Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 8 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(8 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //在写操作里面

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //这里是读取的字节结构：
                    //        //:0101087BCF1680FFFFFFFF1A\r\n
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                    //        //读取的字节结构：7BCF1680FFFFFFFF
                    //        //转换的HEX字节结构：FFFFFFFF8016CF7B
                    //        string sResult = "";
                    //        for (int j = sTemp.Length / 2; j > 0; j--)
                    //        {
                    //            sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //        }

                    //        long lValue = CConverter.HexStringToLong(sResult);

                    //        Value = lValue;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            ////这里是读取的字节结构：
                            ////:0101087BCF1680FFFFFFFF1A\r\n
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                            ////读取的字节结构：7BCF1680FFFFFFFF
                            ////转换的HEX字节结构：FFFFFFFF8016CF7B
                            //string sResult = "";
                            //for (int j = sTemp.Length / 2; j > 0; j--)
                            //{
                            //    sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //}

                            //long lValue = CConverter.HexStringToLong(sResult);

                            //Value = lValue;

                            Value = CConverter.ToInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.Long), ReadInputIOBytesFormat));
                            //Value = CConverter.ToInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 16), ReadInputIOBytesFormat));

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个2双字的输入状态
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度</param>
        /// <param name="Value">返回输入状态多个2双字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputWord(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref long[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 8 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(ReadDataLength * 8 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //在写操作里面

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        long[] lResultValue = new long[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //这里是读取的字节结构：
                    //            //:0101087BCF1680FFFFFFFF1A\r\n
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                    //            //读取的字节结构：7BCF1680FFFFFFFF
                    //            //转换的HEX字节结构：FFFFFFFF8016CF7B
                    //            string sResult = "";
                    //            for (int j = sTemp.Length / 2; j > 0; j--)
                    //            {
                    //                sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //            }

                    //            lResultValue[i] = CConverter.HexStringToLong(sResult);
                    //        }

                    //        Value = lResultValue;
                    //        lResultValue = null;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            //long[] lResultValue = new long[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //这里是读取的字节结构：
                            //    //:0101087BCF1680FFFFFFFF1A\r\n
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                            //    //读取的字节结构：7BCF1680FFFFFFFF
                            //    //转换的HEX字节结构：FFFFFFFF8016CF7B
                            //    string sResult = "";
                            //    for (int j = sTemp.Length / 2; j > 0; j--)
                            //    {
                            //        sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //    }

                            //    lResultValue[i] = CConverter.HexStringToLong(sResult);
                            //}

                            //Value = lResultValue;
                            //lResultValue = null;

                            Value = CConverter.ToInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Long), ReadInputIOBytesFormat));
                            //Value = CConverter.ToInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 16), ReadInputIOBytesFormat));

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站2个双字的输入状态
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入状态2个双字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputWord(byte DeviceAddress, ushort BeginAddress, ref ulong Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 8 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(8 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //在写操作里面

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //这里是读取的字节结构：
                    //        //:0101087BCF1680FFFFFFFF1A\r\n
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                    //        //读取的字节结构：7BCF1680FFFFFFFF
                    //        //转换的HEX字节结构：FFFFFFFF8016CF7B
                    //        string sResult = "";
                    //        for (int j = sTemp.Length / 2; j > 0; j--)
                    //        {
                    //            sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //        }

                    //        ulong lValue = (ulong)CConverter.HexStringToLong(sResult);

                    //        Value = lValue;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            ////这里是读取的字节结构：
                            ////:0101087BCF1680FFFFFFFF1A\r\n
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                            ////读取的字节结构：7BCF1680FFFFFFFF
                            ////转换的HEX字节结构：FFFFFFFF8016CF7B
                            //string sResult = "";
                            //for (int j = sTemp.Length / 2; j > 0; j--)
                            //{
                            //    sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //}

                            //ulong lValue = (ulong)CConverter.HexStringToLong(sResult);

                            //Value = lValue;

                            Value = CConverter.ToUInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.ULong), ReadInputIOBytesFormat));
                            //Value = CConverter.ToUInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 16), ReadInputIOBytesFormat));

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站多个2双字的输入状态
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度</param>
        /// <param name="Value">返回输入状态多个2双字的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputWord(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref ulong[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 8 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputSignal, BeginAddress, Convert.ToUInt16(ReadDataLength * 8 * 8));//

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //在写操作里面

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 2

                    //    string sCmd = ModbusFuncCode.ReadInputSignal.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0102
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        ulong[] lResultValue = new ulong[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //这里是读取的字节结构：
                    //            //:0101087BCF1680FFFFFFFF1A\r\n
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                    //            //读取的字节结构：7BCF1680FFFFFFFF
                    //            //转换的HEX字节结构：FFFFFFFF8016CF7B
                    //            string sResult = "";
                    //            for (int j = sTemp.Length / 2; j > 0; j--)
                    //            {
                    //                sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                    //            }

                    //            lResultValue[i] = (ulong)CConverter.HexStringToLong(sResult);
                    //        }

                    //        Value = lResultValue;
                    //        lResultValue = null;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputSignal.ToString("X2"))//"02"
                        {
                            //ulong[] lResultValue = new ulong[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //这里是读取的字节结构：
                            //    //:0101087BCF1680FFFFFFFF1A\r\n
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                            //    //读取的字节结构：7BCF1680FFFFFFFF
                            //    //转换的HEX字节结构：FFFFFFFF8016CF7B
                            //    string sResult = "";
                            //    for (int j = sTemp.Length / 2; j > 0; j--)
                            //    {
                            //        sResult += Strings.Mid(sTemp, j * 2 - 1, 2);
                            //    }

                            //    lResultValue[i] = (ulong)CConverter.HexStringToLong(sResult);
                            //}

                            //Value = lResultValue;
                            //lResultValue = null;

                            Value = CConverter.ToUInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.ULong), ReadInputIOBytesFormat));
                            //Value = CConverter.ToUInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 16), ReadInputIOBytesFormat));

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        #endregion

        #region "读单个/多个输入寄存器的状态 - ok-ok"

        // ok-ok
        /// <summary>
        /// 读取从站输入寄存器的当前值(short: -32,768 到 32,767)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入寄存器的当前值(short: -32,768 到 32,767)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ref short Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(1));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //每次截取4个16进制字符，转换为int型数据
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);

                    //        Value = (short)CConverter.HexStringToInt(sTemp);

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            ////每次截取4个16进制字符，转换为int型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);

                            //Value = (short)CConverter.HexStringToInt(sTemp);

                            Value = CConverter.ToInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.Short), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 4), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站输入寄存器的当前值(short: -32,768 到 32,767)，函数是以字节为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字</param>
        /// <param name="Value">返回输入寄存器的当前值(short: -32,768 到 32,767)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref short[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~250(字节)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~250(字节)");
                //}

                if (BeginAddress + ReadDataLength * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(ReadDataLength));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        short[] stResultValue = new short[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //每次截取4个16进制字符，转换为int型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);

                    //            stResultValue[i] = (short)CConverter.HexStringToInt(sTemp);
                    //        }

                    //        Value = stResultValue;
                    //        stResultValue = null;

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            //short[] iResultValue = new short[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //每次截取4个16进制字符，转换为int型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);

                            //    iResultValue[i] = (short)CConverter.HexStringToInt(sTemp);
                            //}

                            //Value = iResultValue;
                            //iResultValue = null;

                            Value = CConverter.ToInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Short), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 4), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站输入寄存器的当前值(ushort: 0 到 65535)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入寄存器的当前值(ushort: 0 到 65535)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ref ushort Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(1));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //每次截取4个16进制字符，转换为int型数据
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);

                    //        Value = (ushort)CConverter.HexStringToInt(sTemp);

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            ////每次截取4个16进制字符，转换为int型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);

                            //Value = (ushort)CConverter.HexStringToInt(sTemp);

                            Value = CConverter.ToUInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.UShort), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToUInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 4), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站输入寄存器的当前值(ushort: 0 到 65535)，函数是以字节为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：字</param>
        /// <param name="Value">返回输入寄存器的当前值(ushort: 0 到 65535)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref ushort[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~250(字节)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~250(字节)");
                //}

                if (BeginAddress + ReadDataLength * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(ReadDataLength));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        ushort[] stResultValue = new ushort[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //每次截取4个16进制字符，转换为int型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);

                    //            stResultValue[i] = (ushort)CConverter.HexStringToInt(sTemp);
                    //        }

                    //        Value = stResultValue;
                    //        stResultValue = null;

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            //ushort[] iResultValue = new ushort[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //每次截取4个16进制字符，转换为int型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);

                            //    iResultValue[i] = (ushort)CConverter.HexStringToInt(sTemp);
                            //}

                            //Value = iResultValue;
                            //iResultValue = null;

                            Value = CConverter.ToUInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.UShort), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToUInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 4), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站输入寄存器的当前值(int)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入寄存器的当前值(int)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ref int Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 2 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(2));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //成功执行读命令，结果值：-32548
                //(COM1)发送字符串 - :010400000001FA
                //(COM1)收到字符串 - :01040280DC9D

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n



                    //    #endregion

                    //    //:010402009861\r\n

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //:010404075AFFFF98\r\n
                    //        //每次截取8个16进制字符，转换为int型数据
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);

                    //        //读取的字节结构：075AFFFF
                    //        //转换的HEX字节结构：‭FFFF075A‬

                    //        string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                    //        Value = CConverter.HexStringToInt(sResult);

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            ////:010404075AFFFF98\r\n
                            ////每次截取8个16进制字符，转换为int型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);

                            ////读取的字节结构：075AFFFF
                            ////转换的HEX字节结构：‭FFFF075A‬

                            //string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                            //Value = CConverter.HexStringToInt(sResult);

                            Value = CConverter.ToInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.Int), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 8), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站输入寄存器的当前值(int)，函数是以字节为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：双字</param>
        /// <param name="Value">返回输入寄存器的当前值(int)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref int[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~250(字节)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~250(字节)");
                //}

                if (BeginAddress + ReadDataLength * 2 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(ReadDataLength * 2));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        int[] iResultValue = new int[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //:010404075AFFFF98\r\n
                    //            //每次截取8个16进制字符，转换为int型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);

                    //            //读取的字节结构：075AFFFF
                    //            //转换的HEX字节结构：‭FFFF075A‬

                    //            string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                    //            iResultValue[i] = CConverter.HexStringToInt(sResult);
                    //        }

                    //        Value = iResultValue;
                    //        iResultValue = null;

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            //int[] iResultValue = new int[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //:010404075AFFFF98\r\n
                            //    //每次截取8个16进制字符，转换为int型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);

                            //    //读取的字节结构：075AFFFF
                            //    //转换的HEX字节结构：‭FFFF075A‬

                            //    string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                            //    iResultValue[i] = CConverter.HexStringToInt(sResult);
                            //}

                            //Value = iResultValue;
                            //iResultValue = null;

                            Value = CConverter.ToInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Int), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 8), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站输入寄存器的当前值(uint)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入寄存器的当前值(uint)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ref uint Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 2 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(2));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //成功执行读命令，结果值：-32548
                //(COM1)发送字符串 - :010400000001FA
                //(COM1)收到字符串 - :01040280DC9D

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    //:0184017A\r\n



                    //    #endregion

                    //    //:010402009861\r\n

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //:010404075AFFFF98\r\n
                    //        //每次截取8个16进制字符，转换为int型数据
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);

                    //        //读取的字节结构：075AFFFF
                    //        //转换的HEX字节结构：‭FFFF075A‬

                    //        string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                    //        Value = (uint)CConverter.HexStringToInt(sResult);

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            ////:010404075AFFFF98\r\n
                            ////每次截取8个16进制字符，转换为int型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);

                            ////读取的字节结构：075AFFFF
                            ////转换的HEX字节结构：‭FFFF075A‬

                            //string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                            //Value = (uint)CConverter.HexStringToInt(sResult);

                            Value = CConverter.ToUInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.UInt), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToUInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 8), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站输入寄存器的当前值(uint)，函数是以字节为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：双字</param>
        /// <param name="Value">返回输入寄存器的当前值(uint)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref uint[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~250(字节)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~250(字节)");
                //}

                if (BeginAddress + ReadDataLength * 2 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(ReadDataLength * 2));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        uint[] iResultValue = new uint[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //:010404075AFFFF98\r\n
                    //            //每次截取8个16进制字符，转换为int型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);

                    //            //读取的字节结构：075AFFFF
                    //            //转换的HEX字节结构：‭FFFF075A‬

                    //            string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                    //            iResultValue[i] = (uint)CConverter.HexStringToInt(sResult);
                    //        }

                    //        Value = iResultValue;
                    //        iResultValue = null;

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            //uint[] iResultValue = new uint[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //:010404075AFFFF98\r\n
                            //    //每次截取8个16进制字符，转换为int型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);

                            //    //读取的字节结构：075AFFFF
                            //    //转换的HEX字节结构：‭FFFF075A‬

                            //    string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                            //    iResultValue[i] = (uint)CConverter.HexStringToInt(sResult);
                            //}

                            //Value = iResultValue;
                            //iResultValue = null;

                            Value = CConverter.ToUInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.UInt), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToUInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 8), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站输入寄存器的当前值(float)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入寄存器的当前值(float)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ref float Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 2 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(2));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //每次截取8个16进制字符，转换为float型数据
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);

                    //        byte[] byDataBytes = new byte[4];

                    //        //每次截取8个16进制字符，转换为float型数据
                    //        byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //        byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //        byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //        byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //        Value = BitConverter.ToSingle(byDataBytes, 0);

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            ////每次截取8个16进制字符，转换为float型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);

                            //byte[] byDataBytes = new byte[4];

                            ////每次截取8个16进制字符，转换为float型数据
                            //byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                            //byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                            //byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                            //byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                            //Value = BitConverter.ToSingle(byDataBytes, 0);

                            Value = CConverter.ToFloat(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.Float), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToFloat(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 8), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站输入寄存器的当前值(float)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：双字</param>
        /// <param name="Value">返回输入寄存器的当前值(float)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref float[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + ReadDataLength * 2 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(ReadDataLength * 2));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        float[] fResultData = new float[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //每次截取8个16进制字符，转换为float型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);

                    //            byte[] byDataBytes = new byte[4];

                    //            //每次截取8个16进制字符，转换为float型数据
                    //            byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //            byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //            byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //            byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //            fResultData[i] = BitConverter.ToSingle(byDataBytes, 0);
                    //        }

                    //        Value = fResultData;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            //float[] fResultData = new float[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //每次截取8个16进制字符，转换为float型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);

                            //    byte[] byDataBytes = new byte[4];

                            //    //每次截取8个16进制字符，转换为float型数据
                            //    byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                            //    byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                            //    byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                            //    byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                            //    fResultData[i] = BitConverter.ToSingle(byDataBytes, 0);
                            //}

                            //Value = fResultData;
                            //fResultData = null;

                            Value = CConverter.ToFloatArray(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Float), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToFloatArray(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 8), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        // ?? 测试读取数据时不能像其它功能码一样正确读取double值，在float范围内可以正确读取，其它会对应不上，待更多测试
        /// <summary>
        /// ?? 测试读取数据时不能像其它功能码一样正确读取double值，在float范围内可以正确读取，其它会对应不上，待更多测试
        /// 读取从站输入寄存器的当前值(double)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入寄存器的当前值(double)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ref double Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 4 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(4));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //每次截取16个16进制字符，转换为double型数据
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                    //        byte[] byDataBytes = new byte[8];
                    //        byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //        byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //        byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //        byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //        byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                    //        byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                    //        byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                    //        byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                    //        Value = BitConverter.ToDouble(byDataBytes, 0);
                    //        byDataBytes = null;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            ////每次截取16个16进制字符，转换为double型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                            //byte[] byDataBytes = new byte[8];
                            //byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                            //byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                            //byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                            //byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                            //byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                            //byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                            //byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                            //byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                            //Value = BitConverter.ToDouble(byDataBytes, 0);
                            //byDataBytes = null;

                            Value = CConverter.ToDouble(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.Double), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToDouble(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 16), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// ?? 测试读取数据时不能像其它功能码一样正确读取double值，在float范围内可以正确读取，其它会对应不上，待更多测试
        /// 读取从站输入寄存器的当前值(double)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：4字</param>
        /// <param name="Value">返回输入寄存器的当前值(float)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref double[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + ReadDataLength * 4 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(ReadDataLength * 4));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        double[] dResultData = new double[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //每次截取16个16进制字符，转换为double型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                    //            byte[] byDataBytes = new byte[8];
                    //            byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //            byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //            byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //            byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //            byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                    //            byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                    //            byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                    //            byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                    //            dResultData[i] = BitConverter.ToDouble(byDataBytes, 0);
                    //        }

                    //        Value = dResultData;

                    //        dResultData = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            //double[] dResultData = new double[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //每次截取16个16进制字符，转换为double型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                            //    byte[] byDataBytes = new byte[8];

                            //    byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                            //    byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                            //    byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                            //    byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                            //    byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                            //    byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                            //    byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                            //    byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                            //    dResultData[i] = BitConverter.ToDouble(byDataBytes, 0);
                            //}

                            //Value = dResultData;
                            //dResultData = null;

                            Value = CConverter.ToDoubleArray(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Double), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToDoubleArray(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 16), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        //  ?? 测试读取数据时不能像其它功能码一样正确读取long值，在int范围内可以正确读取，其它会对应不上，待更多测试
        /// <summary>
        /// 读取从站输入寄存器的当前值(long)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入寄存器的当前值(long)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ref long Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 4 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(4));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                
                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //每次截取16个16进制字符，转换为long型数据
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                    //        //这里是读取的字节结构：
                    //        //:010408000280000000000071\r\n
                    //        //读取的字节结构：   0002800000000000
                    //        //转换的HEX字节结构：‭‬0000000080000002

                    //        string sResult = "";
                    //        for (int j = sTemp.Length / 4; j > 0; j--)
                    //        {
                    //            sResult += Strings.Mid(sTemp, (j - 1) * 4 + 1, 4);
                    //        }

                    //        Value = CConverter.HexStringToLong(sResult);

                    //        ////每次截取16个16进制字符，转换为double型数据
                    //        //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);//

                    //        //byte[] byDataBytes = new byte[8];
                    //        //byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //        //byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //        //byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //        //byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //        //byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                    //        //byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                    //        //byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                    //        //byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                    //        //Value = BitConverter.ToInt64(byDataBytes, 0);

                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            ////每次截取16个16进制字符，转换为long型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                            //string sResult = "";
                            ////:01041000028000FFFE7FFF0000000000000000EE\r\n
                            ////读取的字节结构：   00028000FFFE7FFF
                            ////转换的HEX字节结构：‭‬7FFFFFFE80000002

                            //for (int j = sTemp.Length / 4; j > 0; j--)
                            //{
                            //    sResult += Strings.Mid(sTemp, (j - 1) * 4 + 1, 4);
                            //}

                            //Value = CConverter.HexStringToLong(sResult);

                            Value = CConverter.ToInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.Long), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 16), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        //  ?? 测试读取数据时不能像其它功能码一样正确读取long值，在int范围内可以正确读取，其它会对应不上，待更多测试
        /// <summary>
        /// 读取从站输入寄存器的当前值(long)，函数是以字节为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：2双字</param>
        /// <param name="Value">返回输入寄存器的当前值(long)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref long[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~250(字节)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~250(字节)");
                //}

                if (BeginAddress + ReadDataLength * 4 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(ReadDataLength * 4));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                
                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        long[] lResultValue = new long[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //每次截取16个16进制字符，转换为long型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                    //            //这里是读取的字节结构：
                    //            //:01041000028000FFFE7FFF0000000000000000EE\r\n
                    //            //读取的字节结构：   00028000FFFE7FFF
                    //            //转换的HEX字节结构：‭‬7FFFFFFE80000002

                    //            string sResult = "";
                    //            for (int j = sTemp.Length / 4; j > 0; j--)
                    //            {
                    //                sResult += Strings.Mid(sTemp, (j - 1) * 4 + 1, 4);
                    //            }

                    //            lResultValue[i] = CConverter.HexStringToLong(sResult);
                    //        }

                    //        Value = lResultValue;
                    //        lResultValue = null;

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            //long[] lResultValue = new long[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //每次截取16个16进制字符，转换为long型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                            //    //这里是读取的字节结构：
                            //    //:01041000028000FFFE7FFF0000000000000000EE\r\n
                            //    //读取的字节结构：   00028000FFFE7FFF
                            //    //转换的HEX字节结构：‭‬7FFFFFFE80000002

                            //    string sResult = "";
                            //    for (int j = sTemp.Length / 4; j > 0; j--)
                            //    {
                            //        sResult += Strings.Mid(sTemp, (j - 1) * 4 + 1, 4);
                            //    }

                            //    lResultValue[i] = CConverter.HexStringToLong(sResult);
                            //}

                            //Value = lResultValue;
                            //lResultValue = null;

                            Value = CConverter.ToInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Long), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 16), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        //  ?? 测试读取数据时不能像其它功能码一样正确读取long值，在int范围内可以正确读取，其它会对应不上，待更多测试
        /// <summary>
        /// 读取从站输入寄存器的当前值(ulong)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回输入寄存器的当前值(ulong)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ref ulong Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 4 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(4));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //每次截取16个16进制字符，转换为long型数据
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                    //        //这里是读取的字节结构：
                    //        //:010408000280000000000071\r\n
                    //        //读取的字节结构：   0002800000000000
                    //        //转换的HEX字节结构：‭‬0000000080000002

                    //        string sResult = "";
                    //        for (int j = sTemp.Length / 4; j > 0; j--)
                    //        {
                    //            sResult += Strings.Mid(sTemp, (j - 1) * 4 + 1, 4);
                    //        }

                    //        Value = (ulong)CConverter.HexStringToLong(sResult);

                    //        ////每次截取16个16进制字符，转换为double型数据
                    //        //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);//

                    //        //byte[] byDataBytes = new byte[8];
                    //        //byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //        //byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //        //byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //        //byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //        //byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                    //        //byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                    //        //byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                    //        //byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                    //        //Value = BitConverter.ToInt64(byDataBytes, 0);

                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            ////每次截取16个16进制字符，转换为long型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);

                            //string sResult = "";
                            ////:01041000028000FFFE7FFF0000000000000000EE\r\n
                            ////读取的字节结构：   00028000FFFE7FFF
                            ////转换的HEX字节结构：‭‬7FFFFFFE80000002

                            //for (int j = sTemp.Length / 4; j > 0; j--)
                            //{
                            //    sResult += Strings.Mid(sTemp, (j - 1) * 4 + 1, 4);
                            //}

                            //Value = (ulong)CConverter.HexStringToLong(sResult);

                            Value = CConverter.ToUInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.ULong), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToUInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 16), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        //  ?? 测试读取数据时不能像其它功能码一样正确读取long值，在int范围内可以正确读取，其它会对应不上，待更多测试
        /// <summary>
        /// 读取从站输入寄存器的当前值(ulong)，函数是以字节为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：2双字</param>
        /// <param name="Value">返回输入寄存器的当前值(ulong)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadInputRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref ulong[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据长度，有效值范围：1~250(字节)
                //{
                //    throw new Exception("读取数据长度的值不正确，有效值范围：1~250(字节)");
                //}

                if (BeginAddress + ReadDataLength * 4 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadInputRegister, BeginAddress, Convert.ToUInt16(ReadDataLength * 4));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************



                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 4

                    //    string sCmd = ModbusFuncCode.ReadInputRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadInputRegister.ToString()[0])//:0104
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        ulong[] lResultValue = new ulong[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //每次截取16个16进制字符，转换为long型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                    //            //这里是读取的字节结构：
                    //            //:01041000028000FFFE7FFF0000000000000000EE\r\n
                    //            //读取的字节结构：   00028000FFFE7FFF
                    //            //转换的HEX字节结构：‭‬7FFFFFFE80000002

                    //            string sResult = "";
                    //            for (int j = sTemp.Length / 4; j > 0; j--)
                    //            {
                    //                sResult += Strings.Mid(sTemp, (j - 1) * 4 + 1, 4);
                    //            }

                    //            lResultValue[i] = (ulong)CConverter.HexStringToLong(sResult);
                    //        }

                    //        Value = lResultValue;
                    //        lResultValue = null;

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadInputRegister.ToString("X2"))//"04"
                        {
                            //ulong[] lResultValue = new ulong[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //每次截取16个16进制字符，转换为long型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);

                            //    //这里是读取的字节结构：
                            //    //:01041000028000FFFE7FFF0000000000000000EE\r\n
                            //    //读取的字节结构：   00028000FFFE7FFF
                            //    //转换的HEX字节结构：‭‬7FFFFFFE80000002

                            //    string sResult = "";
                            //    for (int j = sTemp.Length / 4; j > 0; j--)
                            //    {
                            //        sResult += Strings.Mid(sTemp, (j - 1) * 4 + 1, 4);
                            //    }

                            //    lResultValue[i] = (ulong)CConverter.HexStringToLong(sResult);
                            //}

                            //Value = lResultValue;
                            //lResultValue = null;

                            Value = CConverter.ToUInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.ULong), ReadInputRegisterBytesFormat));
                            //Value = CConverter.ToUInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 16), ReadInputRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        #endregion

        #region "读单个/多个保持寄存器的状态 - ok-ok"

        // ok-ok
        /// <summary>
        /// 读取从站保持寄存器的当前值(short: -32,768 到 32,767)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回保持寄存器的当前值(short: -32,768 到 32,767)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ref short Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据字长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	         2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节          1个字节       2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(1));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 3

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //每次截取4个16进制字符，转换为int型数据，再转换为short型数据
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);//short	-32,768 到 32,767

                    //        Value = (short)CConverter.HexStringToInt(sTemp);

                    //        //int iValue = (short)CConverter.FourHexStringToInt(sTemp);
                    //        ////转换为short型数据
                    //        //byte[] byCalcIntBytes = BitConverter.GetBytes(iValue);
                    //        //Value = BitConverter.ToInt16(byCalcIntBytes, 0);
                    //        //byCalcIntBytes = null;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            ////每次截取4个16进制字符，转换为int型数据，再转换为short型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);//short	-32,768 到 32,767

                            //Value = (short)CConverter.HexStringToInt(sTemp);

                            Value = CConverter.ToInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, (byte)HexStringCount.Short), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站保持寄存器的当前值(short: -32,768 到 32,767)，函数是以字节为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：short</param>
        /// <param name="Value">返回保持寄存器的当前值(short: -32,768 到 32,767)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref short[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据字长度
                //{
                //    throw new Exception("读取数据字长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(ReadDataLength));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        short[] stResultValue = new short[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //每次截取4个16进制字符，转换为int型数据，再转换为short型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);//short	-32,768 到 32,767

                    //            stResultValue[i] = (short)CConverter.HexStringToInt(sTemp);
                    //        }

                    //        Value = stResultValue;

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //short[] stResultValue = new short[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //每次截取4个16进制字符，转换为int型数据，再转换为short型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);//short	-32,768 到 32,767

                            //    stResultValue[i] = (short)CConverter.HexStringToInt(sTemp);
                            //}

                            //Value = stResultValue;

                            Value = CConverter.ToInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Short), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 4), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站保持寄存器的当前值(ushort: 0 到 65535)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回保持寄存器的当前值(ushort: 0 到 65535)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ref ushort Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据字长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	         2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节          1个字节       2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(1));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 3

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //每次截取4个16进制字符，转换为int型数据，再转换为short型数据
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);//short	-32,768 到 32,767

                    //        Value = (ushort)CConverter.HexStringToInt(sTemp);

                    //        //int iValue = (short)CConverter.FourHexStringToInt(sTemp);
                    //        ////转换为short型数据
                    //        //byte[] byCalcIntBytes = BitConverter.GetBytes(iValue);
                    //        //Value = BitConverter.ToInt16(byCalcIntBytes, 0);
                    //        //byCalcIntBytes = null;

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            ////每次截取4个16进制字符，转换为int型数据，再转换为short型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4);//short	-32,768 到 32,767

                            //Value = (ushort)CConverter.HexStringToInt(sTemp);

                            Value = CConverter.ToUInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, (byte)HexStringCount.UShort), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToUInt16(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 4), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站保持寄存器的当前值(ushort: 0 到 65535)，函数是以字节为读取数据长度单位
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：short</param>
        /// <param name="Value">返回保持寄存器的当前值(ushort: 0 到 65535)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref ushort[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据字长度
                //{
                //    throw new Exception("读取数据字长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(ReadDataLength));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        ushort[] stResultValue = new ushort[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //每次截取4个16进制字符，转换为int型数据，再转换为short型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);//short	-32,768 到 32,767

                    //            stResultValue[i] = (ushort)CConverter.HexStringToInt(sTemp);
                    //        }

                    //        Value = stResultValue;

                    //        stResultValue = null;
                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //ushort[] stResultValue = new ushort[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    //每次截取4个16进制字符，转换为int型数据，再转换为short型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 4, 4);//short	-32,768 到 32,767

                            //    stResultValue[i] = (ushort)CConverter.HexStringToInt(sTemp);
                            //}

                            //Value = stResultValue;
                            //stResultValue = null;

                            Value = CConverter.ToUInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.UShort), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToUInt16Array(CConverter.Hex4StrTo2Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 4), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站保持寄存器的当前值(int)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回保持寄存器的当前值(int)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ref int Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 2 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据字长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	         2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节          1个字节       2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(2));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 3

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);

                    //        //读取的字节结构：075AFFFF
                    //        //转换的HEX字节结构：‭FFFF075A‬
                    //        string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                    //        Value = CConverter.HexStringToInt(sResult);

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);

                            ////读取的字节结构：075AFFFF
                            ////转换的HEX字节结构：‭FFFF075A‬
                            //string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                            //Value = CConverter.HexStringToInt(sResult);

                            Value = CConverter.ToInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, (byte)HexStringCount.Int), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站保持寄存器的当前值(int)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：short</param>
        /// <param name="Value">返回保持寄存器的当前值(int)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref int[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据字长度
                //{
                //    throw new Exception("读取数据字长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 2 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(ReadDataLength * 2));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        int[] iResultValue = new int[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //:010308222B4C6C492A3945FE\r\n
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);

                    //            //读取的字节结构：075AFFFF
                    //            //转换的HEX字节结构：‭FFFF075A‬
                    //            string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                    //            iResultValue[i] = CConverter.HexStringToInt(sResult);
                    //        }

                    //        Value = iResultValue;
                    //        iResultValue = null;

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //int[] iResultValue = new int[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);

                            //    //读取的字节结构：075AFFFF
                            //    //转换的HEX字节结构：‭FFFF075A‬
                            //    string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                            //    iResultValue[i] = CConverter.HexStringToInt(sResult);
                            //}

                            //Value = iResultValue;
                            //iResultValue = null;

                            Value = CConverter.ToInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Int), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 8), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站保持寄存器的当前值(uint)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回保持寄存器的当前值(uint)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ref uint Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 2 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据字长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	         2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节          1个字节       2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(2));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 3

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);

                    //        //读取的字节结构：075AFFFF
                    //        //转换的HEX字节结构：‭FFFF075A‬
                    //        string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                    //        Value = (uint)CConverter.HexStringToInt(sResult);

                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);

                            ////读取的字节结构：075AFFFF
                            ////转换的HEX字节结构：‭FFFF075A‬
                            //string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                            //Value = (uint)CConverter.HexStringToInt(sResult);

                            Value = CConverter.ToUInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.UInt), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToUInt32(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 8), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站保持寄存器的当前值(uint)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：short</param>
        /// <param name="Value">返回保持寄存器的当前值(uint)</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref uint[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (ReadDataLength < 1 || ReadDataLength > 125)//读取数据字长度
                //{
                //    throw new Exception("读取数据字长度的值不正确，有效值范围：1~125(字)");
                //}

                if (BeginAddress + ReadDataLength * 2 * 2 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	       2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节        1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(ReadDataLength * 2));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 1

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        uint[] iResultValue = new uint[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            //:010308222B4C6C492A3945FE\r\n
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);

                    //            //读取的字节结构：075AFFFF
                    //            //转换的HEX字节结构：‭FFFF075A‬
                    //            string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                    //            iResultValue[i] = (uint)CConverter.HexStringToInt(sResult);
                    //        }

                    //        Value = iResultValue;
                    //        iResultValue = null;

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //uint[] iResultValue = new uint[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);

                            //    //读取的字节结构：075AFFFF
                            //    //转换的HEX字节结构：‭FFFF075A‬
                            //    string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                            //    iResultValue[i] = (uint)CConverter.HexStringToInt(sResult);
                            //}

                            //Value = iResultValue;
                            //iResultValue = null;

                            Value = CConverter.ToUInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.UInt), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToUInt32Array(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 8), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站float保持寄存器的当前值(32位浮点值)(float  -3.4×10的38次方 到 +3.4×10的38次方, 精度：7 位)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回float保持寄存器的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ref float Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 4 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据字长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	         2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节          1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(2));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                
                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - F

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);

                    //        //读取的字节结构：075AFFFF
                    //        //转换的HEX字节结构：‭FFFF075A‬
                    //        string sResult = Strings.Mid(sTemp, 5, 4) + Strings.Mid(sTemp, 1, 4);

                    //        byte[] byDataBytes = new byte[4];

                    //        //每次截取8个16进制字符，转换为float型数据
                    //        byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //        byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //        byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //        byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //        Value = BitConverter.ToSingle(byDataBytes, 0);

                    //        byDataBytes = null;
                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //byte[] byDataBytes = new byte[4];

                            ////每次截取8个16进制字符，转换为float型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 8);//
                            //byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                            //byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                            //byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                            //byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                            //Value = BitConverter.ToSingle(byDataBytes, 0);

                            Value = CConverter.ToFloat(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.Float), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToFloat(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 8), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站float保持寄存器的当前值(32位浮点值)(float  -3.4×10的38次方 到 +3.4×10的38次方, 精度：7 位)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：float</param>
        /// <param name="Value">返回float保持寄存器的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref float[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + ReadDataLength * 4 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据字长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	         2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节          1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(ReadDataLength * 2));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - F

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //发送值[0~3]：-1096 4743.429 5829.714 -2837.143 
                //成功执行写命令
                //写操作记录：(COM1)发送字符串 - :011000000008100000C4893B6E45942DB745B65249C53198
                //写操作记录：(COM1)收到字符串 - :011000000008E7

                //成功执行读命令，结果值：-1096 4743.429 
                //(COM1)发送字符串 - :010300000004F8
                //(COM1)收到字符串 - :0103080000C4893B6E459425

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        //-36.265480
                    //        //:0103040FDAC2113C\r\n

                    //        //0.0
                    //        //:01030400000000F8\r\n
                    //        float[] fResultData = new float[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            byte[] byDataBytes = new byte[4];

                    //            //每次截取8个16进制字符，转换为float型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);
                    //            byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //            byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //            byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //            byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //            fResultData[i] = BitConverter.ToSingle(byDataBytes, 0);

                    //            byDataBytes = null;
                    //        }

                    //        Value = fResultData;
                    //        fResultData = null;

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //float[] fResultData = new float[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    byte[] byDataBytes = new byte[4];

                            //    //每次截取8个16进制字符，转换为float型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 8, 8);
                            //    byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                            //    byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                            //    byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                            //    byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                            //    fResultData[i] = BitConverter.ToSingle(byDataBytes, 0);

                            //    byDataBytes = null;
                            //}

                            //Value = fResultData;
                            //fResultData = null;

                            Value = CConverter.ToFloatArray(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Float), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToFloatArray(CConverter.Hex8StrTo4Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 8), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站double(64位浮点值)值到从站保持寄存器(±5.0×10的−324次方 到 ±1.7×10的308次方   精度:15到16位)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回double保持寄存器的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ref double Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 8 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据字长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	         2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节          1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(4));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                
                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - F

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //成功执行写命令-29.1428571428571
                //写操作记录：(COM1)发送字符串 - :01100000000408924949242492C03DE8
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行读命令，结果值：-29.1428571428571
                //(COM1)发送字符串 - :010300000004F8
                //(COM1)收到字符串 - :010308924949242492C03DF9

                //成功执行写命令5415.71428571429
                //写操作记录：(COM1)发送字符串 - :01100000000408B6DBDB6D27B640B538
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行读命令，结果值：5415.71428571429
                //(COM1)发送字符串 - :010300000004F8
                //(COM1)收到字符串 - :010308B6DBDB6D27B640B549

                //成功执行写命令-3825.71428571429
                //写操作记录：(COM1)发送字符串 - :011000000004086DB7B6DBE36DC0AD71
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行读命令，结果值：-3825.71428571429
                //(COM1)发送字符串 - :010300000004F8
                //(COM1)收到字符串 - :0103086DB7B6DBE36DC0AD82

                //成功执行读命令，结果值：-3825.71428571429
                //(COM1)发送字符串 - :010300000004F8
                //(COM1)收到字符串 - :0103086DB7B6DBE36DC0AD82

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {

                    //        byte[] byDataBytes = new byte[8];

                    //        //每次截取16个16进制字符，转换为double型数据
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);//
                    //        byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //        byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //        byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //        byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //        byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                    //        byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                    //        byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                    //        byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                    //        Value = BitConverter.ToDouble(byDataBytes, 0);

                    //        byDataBytes = null;
                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //byte[] byDataBytes = new byte[8];

                            ////每次截取16个16进制字符，转换为double型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);//
                            //byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                            //byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                            //byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                            //byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                            //byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                            //byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                            //byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                            //byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                            //Value = BitConverter.ToDouble(byDataBytes, 0);

                            Value = CConverter.ToDouble(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.Double), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToDouble(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 16), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站double(64位浮点值)值到从站保持寄存器(±5.0×10的−324次方 到 ±1.7×10的308次方   精度:15到16位)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：double</param>
        /// <param name="Value">返回double保持寄存器的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref double[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + ReadDataLength * 8 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据字长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	         2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节          1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(ReadDataLength * 4));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - F

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //发送值[0~3]：-6502 -5821.14306640625 539.714294433594 -6940.5712890625 
                //成功执行写命令
                //写操作记录：(COM1)发送字符串 - :01100000001020000000006600C0B90000A000BD24C0B60000E000DDB64080000040001C92C0BB4D
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //成功执行读命令，结果值：-6502 -5821.14306640625 
                //(COM1)发送字符串 - :010300000008F4
                //(COM1)收到字符串 - :010310000000006600C0B90000A000BD24C0B616

                //发送值[0~3]：7027.4287109375 5529.4287109375 -7479.71435546875 -5750.5712890625 
                //成功执行写命令
                //写操作记录：(COM1)发送字符串 - :011000000010200000C000736D40BB0000C000996D40B50000E00037B6C0BD000040007692C0B661
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //成功执行读命令，结果值：7027.4287109375 5529.4287109375 
                //(COM1)发送字符串 - :010300000008F4
                //(COM1)收到字符串 - :0103100000C000736D40BB0000C000996D40B596

                //发送值[0~3]：6341.14306640625 -2607.14282226563 1535.14282226563 -3786
                //写操作记录：(COM1)发送字符串 - :011000000010200000A000C52440B8000020005E49C0A400004000FC924097000000009400C0AD6D
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //成功执行读命令，结果值：6341.14306640625 -2607.14282226563 
                //(COM1)发送字符串 - :010300000008F4
                //(COM1)收到字符串 - :0103100000A000C52440B8000020005E49C0A440

                //发送值[0~3]：9072.5712890625 6789.4287109375 -6218.85693359375 3906
                //写操作记录：(COM1)发送字符串 - :0110000000102000002000B84940C10000C000856D40BA000060004ADBC0B800000000840040AE82
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //成功执行读命令，结果值：9072.5712890625 6789.4287109375 
                //(COM1)发送字符串 - :010300000008F4
                //(COM1)收到字符串 - :01031000002000B84940C10000C000856D40BA1E

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        double[] dResultValue = new double[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            byte[] byDataBytes = new byte[8];

                    //            //每次截取16个16进制字符，转换为double型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);//
                    //            byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //            byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //            byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //            byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //            byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                    //            byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                    //            byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                    //            byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                    //            dResultValue[i] = BitConverter.ToDouble(byDataBytes, 0);

                    //            byDataBytes = null;
                    //        }

                    //        Value = dResultValue;
                    //        dResultValue = null;

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //double[] dResultValue = new double[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    byte[] byDataBytes = new byte[8];

                            //    //每次截取16个16进制字符，转换为double型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);//
                            //    byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                            //    byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                            //    byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                            //    byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                            //    byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                            //    byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                            //    byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                            //    byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                            //    dResultValue[i] = BitConverter.ToDouble(byDataBytes, 0);

                            //    byDataBytes = null;
                            //}

                            //Value = dResultValue;
                            //dResultValue = null;

                            Value = CConverter.ToDoubleArray(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Double), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToDoubleArray(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 16), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站long(64位整数值)值到从站保持寄存器(-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807, 有符号 64 位整数)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回long保持寄存器的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ref long Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 8 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据字长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	         2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节          1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(4));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - F

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //成功执行写命令-105431462
                //写操作记录：(COM1)发送字符串 - :011000000004083E5AF9B7FFFFFFFF9F
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行读命令，结果值：-105431462
                //(COM1)发送字符串 - :010300000004F8
                //(COM1)收到字符串 - :0103083E5AF9B7FFFFFFFFB0

                //成功执行写命令1325929153
                //写操作记录：(COM1)发送字符串 - :0110000000040812C14F0800000000B9
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行读命令，结果值：1325929153
                //(COM1)发送字符串 - :010300000004F8
                //(COM1)收到字符串 - :01030812C14F0800000000CA

                //成功执行写命令218182470
                //写操作记录：(COM1)发送字符串 - :0110000000040833460D01000000005C
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行读命令，结果值：218182470
                //(COM1)发送字符串 - :010300000004F8
                //(COM1)收到字符串 - :01030833460D01000000006D

                //成功执行写命令-1344473489
                //写操作记录：(COM1)发送字符串 - :01100000000408F66FAFDCFFFFFFFFF7
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行读命令，结果值：-1344473489
                //(COM1)发送字符串 - :010300000004F8
                //(COM1)收到字符串 - :010308F66FAFDCFFFFFFFF08

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {

                    //        byte[] byDataBytes = new byte[8];

                    //        //每次截取16个16进制字符，转换为double型数据
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);//
                    //        byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //        byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //        byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //        byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //        byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                    //        byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                    //        byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                    //        byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                    //        Value = BitConverter.ToInt64(byDataBytes, 0);

                    //        byDataBytes = null;
                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //byte[] byDataBytes = new byte[8];

                            ////每次截取16个16进制字符，转换为double型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);//
                            //byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                            //byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                            //byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                            //byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                            //byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                            //byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                            //byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                            //byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                            //Value = BitConverter.ToInt64(byDataBytes, 0);

                            Value = CConverter.ToInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.Long), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 16), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站long(64位整数值)值到从站保持寄存器(-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807, 有符号 64 位整数)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：double</param>
        /// <param name="Value">返回long保持寄存器的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref long[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + ReadDataLength * 8 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据字长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	         2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节          1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(ReadDataLength * 4));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - F

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //发送值[0~3]：1560360770 -330733133 -559386401 -358732414 
                //成功执行写命令
                //写操作记录：(COM1)发送字符串 - :0110000000102037425D010000000069B3EC49FFFFFFFF70DFDEA8FFFFFFFF2D82EA9EFFFFFFFF97
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //成功执行读命令，结果值：1560360770 -330733133 
                //(COM1)发送字符串 - :010300000008F4
                //(COM1)收到字符串 - :01031037425D010000000069B3EC49FFFFFFFFC8

                //发送值[0~3]：-1745165922 1859478028 -204545940 -347596378
                //写操作记录：(COM1)发送字符串 - :01100000001020E19E97FAFFFFFFFF620C6ED500000000E06CF3CEFFFFFFFF19A6EB48FFFFFFFF0B
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //成功执行读命令，结果值：-1745165922 1859478028 
                //(COM1)发送字符串 - :010300000008F4
                //(COM1)收到字符串 - :010310E19E97FAFFFFFFFF620C6ED5000000002F

                //发送值[0~3]：-1099268831 567276160 1472460616 -1051978640
                //写操作记录：(COM1)发送字符串 - :011000000010207D21BE7AFFFFFFFFF28021CF00000000F74857C3000000001470C14CFFFFFFFFA5
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //成功执行读命令，结果值：-1099268831 567276160 
                //(COM1)发送字符串 - :010300000008F4
                //(COM1)收到字符串 - :0103107D21BE7AFFFFFFFFF28021CF00000000B8

                //发送值[0~3]：1123495095 1423358440 -2142490831 -1573317120
                //写操作记录：(COM1)发送字符串 - :011000000010202CB742F700000000B9E854D6000000002F31804CFFFFFFFF1600A239FFFFFFFFC3
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //成功执行读命令，结果值：1123495095 1423358440 
                //(COM1)发送字符串 - :010300000008F4
                //(COM1)收到字符串 - :0103102CB742F700000000B9E854D60000000005

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        long[] lResultValue = new long[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            byte[] byDataBytes = new byte[8];

                    //            //每次截取16个16进制字符，转换为double型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);//
                    //            byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //            byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //            byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //            byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //            byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                    //            byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                    //            byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                    //            byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                    //            lResultValue[i] = BitConverter.ToInt64(byDataBytes, 0);

                    //            byDataBytes = null;
                    //        }

                    //        Value = lResultValue;
                    //        lResultValue = null;

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //long[] lResultValue = new long[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    byte[] byDataBytes = new byte[8];

                            //    //每次截取16个16进制字符，转换为double型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);//
                            //    byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                            //    byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                            //    byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                            //    byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                            //    byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                            //    byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                            //    byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                            //    byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                            //    lResultValue[i] = BitConverter.ToInt64(byDataBytes, 0);

                            //    byDataBytes = null;
                            //}

                            //Value = lResultValue;
                            //lResultValue = null;

                            Value = CConverter.ToInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.Long), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 16), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站ulong(64位无符号整数值)值到从站保持寄存器(0 到 18,446,744,073,709,551,615)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="Value">返回ulong保持寄存器的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ref ulong Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 8 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据字长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	         2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节          1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(4));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - F

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {

                    //        byte[] byDataBytes = new byte[8];

                    //        //每次截取16个16进制字符，转换为double型数据
                    //        string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);//
                    //        byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //        byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //        byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //        byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //        byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                    //        byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                    //        byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                    //        byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                    //        Value = BitConverter.ToUInt64(byDataBytes, 0);

                    //        byDataBytes = null;
                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //byte[] byDataBytes = new byte[8];

                            ////每次截取16个16进制字符，转换为double型数据
                            //string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 16);//
                            //byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                            //byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                            //byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                            //byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                            //byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                            //byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                            //byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                            //byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                            //Value = BitConverter.ToUInt64(byDataBytes, 0);

                            Value = CConverter.ToUInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, 1 * (byte)HexStringCount.ULong), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToUInt64(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, 1 * 16), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        // ok-ok
        /// <summary>
        /// 读取从站ulong(64位无符号整数值)值到从站保持寄存器(0 到 18,446,744,073,709,551,615)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，单位：double</param>
        /// <param name="Value">返回ulong保持寄存器的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool ReadKeepRegister(byte DeviceAddress, ushort BeginAddress, ushort ReadDataLength, ref ulong[] Value)//  , out string ReadBackData)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + ReadDataLength * 8 * 8 > 65535)
                {
                    throw new Exception("读取地址超出范围，正确寻址范围：0~65535(位)");
                }

                //起始位	    设备地址	功能代码	起始地址   	读取数据字长度   LRC校验	   结束符
                //1个字符(:)	2个字符	    2个字符	    4个字符     4个字符	         2个字符	   2个字符(回车+换行)
                //1个字节       1个字节     1个字节     2个字节     2个字节          1个字节     2个字节
                byte[] byResult = PackReadCmd(DeviceAddress, ModbusFuncCode.ReadRegister, BeginAddress, Convert.ToUInt16(ReadDataLength * 4));

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)
                //{
                //    Enqueue( "发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - F

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************


                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    ////sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    //ReadBackData = "";
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTempResult = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 3

                    //    string sCmd = ModbusFuncCode.ReadRegister.ToString("X2");

                    //    //if (cByte3 == 0x0.ToString()[0] && cByte4 == CModbusFunctionCode.ReadRegister.ToString()[0])//:0103
                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])
                    //    {
                    //        ulong[] lResultValue = new ulong[ReadDataLength];

                    //        for (int i = 0; i < ReadDataLength; i++)
                    //        {
                    //            byte[] byDataBytes = new byte[8];

                    //            //每次截取16个16进制字符，转换为double型数据
                    //            string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);//
                    //            byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                    //            byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                    //            byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                    //            byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                    //            byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                    //            byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                    //            byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                    //            byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                    //            lResultValue[i] = BitConverter.ToUInt64(byDataBytes, 0);

                    //            byDataBytes = null;
                    //        }

                    //        Value = lResultValue;
                    //        lResultValue = null;

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);

                    //        sFeedBackFromSlave = null;
                    //    //byReadData = null;
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//null == byReadData || byReadData.Length < 2
                    {
                        //ReadBackData = "";
                        return false;
                    }
                    else
                    {
                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.ReadRegister.ToString("X2"))//"03"
                        {
                            //ulong[] lResultValue = new ulong[ReadDataLength];

                            //for (int i = 0; i < ReadDataLength; i++)
                            //{
                            //    byte[] byDataBytes = new byte[8];

                            //    //每次截取16个16进制字符，转换为double型数据
                            //    string sTemp = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData + i * 16, 16);//
                            //    byDataBytes[0] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 3, 2));
                            //    byDataBytes[1] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 1, 2));
                            //    byDataBytes[2] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 7, 2));
                            //    byDataBytes[3] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 5, 2));

                            //    byDataBytes[4] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 11, 2));
                            //    byDataBytes[5] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 9, 2));
                            //    byDataBytes[6] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 15, 2));
                            //    byDataBytes[7] = CConverter.TwoHexCharsToByte(Strings.Mid(sTemp, 13, 2));

                            //    lResultValue[i] = BitConverter.ToUInt64(byDataBytes, 0);

                            //    byDataBytes = null;
                            //}

                            //Value = lResultValue;
                            //lResultValue = null;

                            Value = CConverter.ToUInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, ReadDataLength * (byte)HexStringCount.ULong), ReadKeepRegisterBytesFormat));
                            //Value = CConverter.ToUInt64Array(CConverter.Hex16StrTo8Bytes(Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, ReadDataLength * 16), ReadKeepRegisterBytesFormat));

                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);

                            sFeedBackFromSlave = null;
                            //throw new Exception("");
                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                //ReadBackData = "";
                return false;
            }
        }

        #endregion

        #endregion

        #region "写 - ok-ok"

        #region "写单个/多个线圈 - ok-ok"

        // ok-ok
        /// <summary>
        /// 写从站线圈(位 - bit)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="IsOn">设置线圈的当前值：true - On; false - Off</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilBit(byte DeviceAddress, ushort BeginAddress, bool IsOn)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //:         地址码         功能码    设置起始地址   设置值      LRC     回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节    2字节

                // 求 LRC -- 设备地址(2个字符) + 功能码(2个字符) + 起始地址(4个字符) + 数据值(4个字符)
                string sTemp = IsOn == true ? "FF00" : "0000";
                string sData = CConverter.Reorder2HexStrData(sTemp, WriteCoilBytesFormat);

                byte[] byResult = PackSingleWriteCmd(DeviceAddress, ModbusFuncCode.WriteCoil, BeginAddress, sData);

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                //// 单个线圈值的设置
                ////0x0000	释放继电器线圈
                ////0xFF00	吸合继电器线圈
                //if (IsOn == true)
                //{
                //    sCmdToCalcLRC += "FF00";
                //}
                //else
                //{
                //    sCmdToCalcLRC += "0000";
                //}
                ////byte[] byDataLength = IntToHex(1);//数据长度(4个字符)
                ////sCmdToCalcLRC += byDataLength[0].ToString("X2");
                ////sCmdToCalcLRC += byDataLength[1].ToString("X2");

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01850179  -- 写从站线圈失败后，

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01050000FF00FB  -- 成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                    //    //if (byReadData[0] == PrefixByte && byReadData[1] == CModbusFunctionCode.WriteCoil)//
                    //    //{
                    //    //}

                    //    //3A 30 31 30 35 30 30 30 30 46 46 30 30 46 42 0D 0A -- 写线圈OK
                    //    //3A 30 31 38 35 30 36 37 34 0D 0A -- 错误
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 5

                    //    //string sByte3 = byReadData[3].ToString("X2");//功能码的第一个字节 - 0
                    //    //string sByte4 = byReadData[4].ToString("X2");//功能码的第一个字节 - 5

                    //    string sCmd = CModbusFuncCode.WriteCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//:0105
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0105
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"

                        //(COM1)发送字符串 - :01050000FF00FB
                        //(COM1)收到字符串 - :01850179  -- 写从站线圈失败后，

                        //(COM1)发送字符串 - :01050000FF00FB
                        //(COM1)收到字符串 - :01050000FF00FB  -- 成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                        #endregion

                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteCoil.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }

                #region "Old codes"

                //byte[] byResult = null;

                //byte[] byDataToBeSent = new byte[6];//[8]

                //byDataToBeSent[0] = DeviceAddress;	//设备地址

                //byDataToBeSent[1] = CModbusFunctionCode.WriteCoil;	//功能号码

                //// 起始地址
                //byte[] byStartAddress = BitConverter.GetBytes(BeginAddress);
                //byDataToBeSent[2] = byStartAddress[1];  // 起始地址 - 高字节
                //byDataToBeSent[3] = byStartAddress[0];  // 起始地址 - 低字节

                //byResult = JoinTwoByteArrays(new byte[] { DeviceAddress }, byStartAddress);

                //byte[] byWriteValue = new byte[2];
                //byWriteValue[0] = Convert.ToByte((IsOn == true) ? 0xFF : 0x00);
                //byWriteValue[1] = 0x00; //低字节

                //// 单个线圈值的设置
                ////0x0000	释放继电器线圈
                ////0xFF00	吸合继电器线圈
                //if (IsOn == true)
                //{
                //    byDataToBeSent[4] = 0xFF; //高字节 - 吸合继电器线圈
                //}
                //else
                //{
                //    byDataToBeSent[4] = 0x00; //高字节 - 释放继电器线圈
                //}

                //byDataToBeSent[5] = 0x00; //低字节

                ////LRC校验结果值
                //byte[] byCRCResults = CLRC.LRC(byDataToBeSent);
                //Array.Resize<byte>(ref byDataToBeSent, 8);
                //byDataToBeSent[6] = byCRCResults[1];
                //byDataToBeSent[7] = byCRCResults[0];

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byDataToBeSent, 0, byDataToBeSent.Length);

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= SleepTime)
                //    {
                //        break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //if (null == byReadData || byReadData.Length < 2)
                //{
                //    return false;
                //}
                //else
                //{
                //    if (byReadData[0] == CModbusFunctionCode.WriteCoil)
                //    {

                //    }
                //}

                #endregion
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站线圈字节(位 - bit；1字节 = 8bit)，写线圈的布尔数组长度必须是8的整数倍
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置8*N个线圈的当前值数组：true - On; false - Off</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilBit(byte DeviceAddress, ushort BeginAddress, bool[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                if (SetValue.Length % 8 != 0)
                {
                    throw new Exception("bool[]数组的长度不是8的整数，即不是以整字节的形式，请修改参数数组的长度");
                }

                //if (SetValue.Length > 1968)
                //{
                //    throw new Exception("设置值bool[]数组的长度超出范围(1~1968)，请修改参数数组的长度");
                //}

                if (BeginAddress + SetValue.Length > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //if (BeginAddress + SetValue.Length > 65535)
                //{
                //    throw new Exception("起始地址加bool[]数组的长度超出寻址范围，请修改起始地址或参数数组的长度");
                //}

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节



                string sData = CConverter.Bytes2To4HexStr(CConverter.BitArrayToByte(SetValue), WriteCoilBytesFormat);
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, SetValue.Length, SetValue.Length / 8, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = SetValue.Length;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength / 8);//bool[]数组长度 / 8 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置 - 将布尔数组转换为字节数组
                //byte[] byBitArrayToBytes = CConverter.BitArrayToByte(SetValue);
                //for (int i = 0; i < byBitArrayToBytes.Length; i++)
                //{
                //    sCmdToCalcLRC += byBitArrayToBytes[i].ToString("X2");
                //}

                ////byte[] byDataLength = IntToHex(1);//数据长度(4个字符)
                ////sCmdToCalcLRC += byDataLength[0].ToString("X2");
                ////sCmdToCalcLRC += byDataLength[1].ToString("X2");

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01850179  -- 写从站线圈失败后，

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01050000FF00FB  -- 成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                    //    //if (byReadData[0] == PrefixByte && byReadData[1] == CModbusFunctionCode.WriteCoil)//
                    //    //{
                    //    //}

                    //    //3A 30 31 30 35 30 30 30 30 46 46 30 30 46 42 0D 0A -- 写线圈OK
                    //    //3A 30 31 38 35 30 36 37 34 0D 0A -- 错误
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    //发送值[0~7]：True False True False True False False False 
                    //    //写操作记录：(COM1)发送字符串 - :010F000000080815CB
                    //    //写操作记录：(COM1)收到字符串 - :018F036D

                    //    //发送值[0~7]：False True True True False False True False
                    //    //写操作记录：(COM1)发送字符串 - :010F00000008014E99
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //发送值[0~7]：True False False True False True False False
                    //    //写操作记录：(COM1)发送字符串 - :010F000000080129BE
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //发送值[0~7]：True True True False True False True False
                    //    //写操作记录：(COM1)发送字符串 - :010F00000008015790
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //发送值[0~7]：False False True False False True True False
                    //    //写操作记录：(COM1)发送字符串 - :010F00000008016483
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //3A 30 31 30 46 30 30 30 30 30 30 30 31 45 46 0D 0A
                    //    // :018F036D\r\n

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        #region "通讯记录"

                        // *** 写从站多个线圈失败后，

                        //发送值[0~7]：True False True False True False False False
                        //写操作记录：(COM1)发送字符串 - :010F000000080815CB
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        //***************************
                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //发送值[0~7]：False False True False False True True False
                        //写操作记录：(COM1)发送字符串 - :010F00000008016483
                        //写操作记录：(COM1)收到字符串 - :010F00000008E8

                        //发送值[0~15]：False True True True False False False False True True False True True False False True
                        //写操作记录：(COM1)发送字符串 - :010F00000010020E9B35
                        //写操作记录：(COM1)收到字符串 - :010F00000010E0

                        //发送值[0~15]：False True True False True True True True False False False False True True True False
                        //写操作记录：(COM1)发送字符串 - :010F0000001002F67078
                        //写操作记录：(COM1)收到字符串 - :010F00000010E0

                        //发送值[0~15]：True True False True False False True False False False False True False True False False
                        //写操作记录：(COM1)发送字符串 - :010F00000010024B286B
                        //写操作记录：(COM1)收到字符串 - :010F00000010E0

                        #endregion

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))//sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站1个字节的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置1个字节线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilByte(byte DeviceAddress, ushort BeginAddress, byte SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress + 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Byte1To2HexStr(SetValue);
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, 1 * 8, 1, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = 1 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength / 8);//1 - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //sCmdToCalcLRC += SetValue.ToString("X2");

                ////byte[] byDataLength = IntToHex(1);//数据长度(4个字符)
                ////sCmdToCalcLRC += byDataLength[0].ToString("X2");
                ////sCmdToCalcLRC += byDataLength[1].ToString("X2");

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //成功执行写命令192
                //写操作记录：(COM1)发送字符串 - :010F0000000801C027
                //写操作记录：(COM1)收到字符串 - :010F00000008E8

                //成功执行读命令，结果值：192
                //(COM1)发送字符串 - :010100000008F6
                //(COM1)收到字符串 - :010101C03D

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01850179  -- 写从站线圈失败后，

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01050000FF00FB  -- 成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                    //    //if (byReadData[0] == PrefixByte && byReadData[1] == CModbusFunctionCode.WriteCoil)//
                    //    //{
                    //    //}

                    //    //3A 30 31 30 35 30 30 30 30 46 46 30 30 46 42 0D 0A -- 写线圈OK
                    //    //3A 30 31 38 35 30 36 37 34 0D 0A -- 错误
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    //发送值[0~7]：True False True False True False False False 
                    //    //写操作记录：(COM1)发送字符串 - :010F000000080815CB
                    //    //写操作记录：(COM1)收到字符串 - :018F036D

                    //    //发送值[0~7]：False True True True False False True False
                    //    //写操作记录：(COM1)发送字符串 - :010F00000008014E99
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //发送值[0~7]：True False False True False True False False
                    //    //写操作记录：(COM1)发送字符串 - :010F000000080129BE
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //发送值[0~7]：True True True False True False True False
                    //    //写操作记录：(COM1)发送字符串 - :010F00000008015790
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //发送值[0~7]：False False True False False True True False
                    //    //写操作记录：(COM1)发送字符串 - :010F00000008016483
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //3A 30 31 30 46 30 30 30 30 30 30 30 31 45 46 0D 0A
                    //    // :018F036D\r\n

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))//sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站N个字节的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置N个字节线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilByte(byte DeviceAddress, ushort BeginAddress, byte[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                //if (SetValue.Length * 8 > 1968)
                //{
                //    throw new Exception("设置值byte[]数组的长度超出范围(1~246)，请修改参数数组的长度");
                //}

                if (BeginAddress + SetValue.Length * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes1To2HexStr(SetValue);
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, SetValue.Length * 8, SetValue.Length, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = SetValue.Length * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength / 8);//N - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //for (int i = 0; i < SetValue.Length; i++)
                //{
                //    sCmdToCalcLRC += SetValue[i].ToString("X2");
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //发送值[0~1]：215 33 
                //成功执行写命令
                //写操作记录：(COM1)发送字符串 - :010F0000001002D721E6
                //写操作记录：(COM1)收到字符串 - :010F00000010E0

                //成功执行读命令，结果值：215 33 
                //(COM1)发送字符串 - :010100000010EE
                //(COM1)收到字符串 - :010102D72104

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01850179  -- 写从站线圈失败后，

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01050000FF00FB  -- 成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                    //    //if (byReadData[0] == PrefixByte && byReadData[1] == CModbusFunctionCode.WriteCoil)//
                    //    //{
                    //    //}

                    //    //3A 30 31 30 35 30 30 30 30 46 46 30 30 46 42 0D 0A -- 写线圈OK
                    //    //3A 30 31 38 35 30 36 37 34 0D 0A -- 错误
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    //发送值[0~7]：True False True False True False False False 
                    //    //写操作记录：(COM1)发送字符串 - :010F000000080815CB
                    //    //写操作记录：(COM1)收到字符串 - :018F036D

                    //    //发送值[0~7]：False True True True False False True False
                    //    //写操作记录：(COM1)发送字符串 - :010F00000008014E99
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //发送值[0~7]：True False False True False True False False
                    //    //写操作记录：(COM1)发送字符串 - :010F000000080129BE
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //发送值[0~7]：True True True False True False True False
                    //    //写操作记录：(COM1)发送字符串 - :010F00000008015790
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //发送值[0~7]：False False True False False True True False
                    //    //写操作记录：(COM1)发送字符串 - :010F00000008016483
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //3A 30 31 30 46 30 30 30 30 30 30 30 31 45 46 0D 0A
                    //    // :018F036D\r\n

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))//sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站1个字节的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置1个字节线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilByte(byte DeviceAddress, ushort BeginAddress, sbyte SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress + 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Byte1To2HexStr((byte)SetValue);
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, 1 * 8, 1, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = 1 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength / 8);//1 - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //sCmdToCalcLRC += SetValue.ToString("X2");

                ////byte[] byDataLength = IntToHex(1);//数据长度(4个字符)
                ////sCmdToCalcLRC += byDataLength[0].ToString("X2");
                ////sCmdToCalcLRC += byDataLength[1].ToString("X2");

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //成功执行写命令192
                //写操作记录：(COM1)发送字符串 - :010F0000000801C027
                //写操作记录：(COM1)收到字符串 - :010F00000008E8

                //成功执行读命令，结果值：192
                //(COM1)发送字符串 - :010100000008F6
                //(COM1)收到字符串 - :010101C03D

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))//sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        //  ok-ok
        /// <summary>
        /// 写从站N个字节的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置N个字节线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilByte(byte DeviceAddress, ushort BeginAddress, sbyte[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                //if (SetValue.Length * 8 > 1968)
                //{
                //    throw new Exception("设置值byte[]数组的长度超出范围(1~246)，请修改参数数组的长度");
                //}

                if (BeginAddress + SetValue.Length * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes1To2HexStr(SetValue);
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, SetValue.Length * 8, SetValue.Length, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = SetValue.Length * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength / 8);//N - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //for (int i = 0; i < SetValue.Length; i++)
                //{
                //    sCmdToCalcLRC += SetValue[i].ToString("X2");
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //发送值[0~1]：215 33 
                //成功执行写命令
                //写操作记录：(COM1)发送字符串 - :010F0000001002D721E6
                //写操作记录：(COM1)收到字符串 - :010F00000010E0

                //成功执行读命令，结果值：215 33 
                //(COM1)发送字符串 - :010100000010EE
                //(COM1)收到字符串 - :010102D72104

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01850179  -- 写从站线圈失败后，

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01050000FF00FB  -- 成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                    //    //if (byReadData[0] == PrefixByte && byReadData[1] == CModbusFunctionCode.WriteCoil)//
                    //    //{
                    //    //}

                    //    //3A 30 31 30 35 30 30 30 30 46 46 30 30 46 42 0D 0A -- 写线圈OK
                    //    //3A 30 31 38 35 30 36 37 34 0D 0A -- 错误
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    //发送值[0~7]：True False True False True False False False 
                    //    //写操作记录：(COM1)发送字符串 - :010F000000080815CB
                    //    //写操作记录：(COM1)收到字符串 - :018F036D

                    //    //发送值[0~7]：False True True True False False True False
                    //    //写操作记录：(COM1)发送字符串 - :010F00000008014E99
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //发送值[0~7]：True False False True False True False False
                    //    //写操作记录：(COM1)发送字符串 - :010F000000080129BE
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //发送值[0~7]：True True True False True False True False
                    //    //写操作记录：(COM1)发送字符串 - :010F00000008015790
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //发送值[0~7]：False False True False False True True False
                    //    //写操作记录：(COM1)发送字符串 - :010F00000008016483
                    //    //写操作记录：(COM1)收到字符串 - :010F00000008E8

                    //    //3A 30 31 30 46 30 30 30 30 30 30 30 31 45 46 0D 0A
                    //    // :018F036D\r\n

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))//sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站1个字的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置1个字线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilWord(byte DeviceAddress, ushort BeginAddress, short SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress + 2 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes2To4HexStr(CConverter.ToBytes(SetValue, WriteCoilBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, 2 * 8, 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = 2 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = 2;// Convert.ToByte(iDataLength / 8);//2 - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //byte[] byTemp = BitConverter.GetBytes(SetValue);
                //sCmdToCalcLRC += byTemp[0].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[1].ToString("X2");// 数据设置值 - 低字节

                ////byte[] byDataLength = IntToHex(1);//数据长度(4个字符)
                ////sCmdToCalcLRC += byDataLength[0].ToString("X2");
                ////sCmdToCalcLRC += byDataLength[1].ToString("X2");

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //成功执行写命令12320
                //写操作记录：(COM1)发送字符串 - :010F000000100220308E
                //写操作记录：(COM1)收到字符串 - :010F00000010E0

                //成功执行读命令，结果值：12320
                //(COM1)发送字符串 - :010100000010EE
                //(COM1)收到字符串 - :0101022030AC

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01850179  -- 写从站线圈失败后，

                    //    //(COM1)收到字符串 - :01050000FF00FB  -- 成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                    //    //3A 30 31 30 46 30 30 30 30 30 30 30 31 45 46 0D 0A
                    //    // :018F036D\r\n

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))
                        //sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站N个字的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置N个字线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilWord(byte DeviceAddress, ushort BeginAddress, short[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                //if (SetValue.Length * 2 * 8 > 1968)
                //{
                //    throw new Exception("设置值byte[]数组的长度超出范围(1~123)，请修改参数数组的长度");
                //}

                if (BeginAddress + SetValue.Length * 2 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes2To4HexStr(CConverter.ToBytes(SetValue, WriteCoilBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, SetValue.Length * 2 * 8, SetValue.Length * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = SetValue.Length * 2 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(SetValue.Length * 2);//N - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //for (int i = 0; i < SetValue.Length; i++)
                //{
                //    //sCmdToCalcLRC += SetValue[i].ToString("X4");

                //    byte[] byTemp = BitConverter.GetBytes(SetValue[i]);
                //    sCmdToCalcLRC += byTemp[0].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[1].ToString("X2");// 数据设置值 - 低字节
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //发送值[0~1]：-455 -32647 
                //成功执行写命令
                //写操作记录：(COM1)发送字符串 - :010F000000200439FE79809C
                //写操作记录：(COM1)收到字符串 - :010F00000020D0

                //成功执行读命令，结果值：-455 -32647 
                //(COM1)发送字符串 - :010100000020DE
                //(COM1)收到字符串 - :01010439FE7980CA

                //发送值[0~1]：-4316 24771
                //写操作记录：(COM1)发送字符串 - :010F000000200424EFC36096
                //写操作记录：(COM1)收到字符串 - :010F00000020D0

                //成功执行读命令，结果值：-4316 24771 
                //(COM1)发送字符串 - :010100000020DE
                //(COM1)收到字符串 - :01010424EFC360C4

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01850179  -- 写从站线圈失败后，

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01050000FF00FB  -- 成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                    //    //3A 30 31 30 46 30 30 30 30 30 30 30 31 45 46 0D 0A
                    //    // :018F036D\r\n

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))//sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        //  ok-ok
        /// <summary>
        /// 写从站1个字的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置1个字线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilWord(byte DeviceAddress, ushort BeginAddress, ushort SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress + 2 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes2To4HexStr(CConverter.ToBytes(SetValue, WriteCoilBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, 2 * 8, 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = 2 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = 2;// Convert.ToByte(iDataLength / 8);//2 - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //byte[] byTemp = BitConverter.GetBytes(SetValue);
                //sCmdToCalcLRC += byTemp[0].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[1].ToString("X2");// 数据设置值 - 低字节

                ////byte[] byDataLength = IntToHex(1);//数据长度(4个字符)
                ////sCmdToCalcLRC += byDataLength[0].ToString("X2");
                ////sCmdToCalcLRC += byDataLength[1].ToString("X2");

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //成功执行写命令12320
                //写操作记录：(COM1)发送字符串 - :010F000000100220308E
                //写操作记录：(COM1)收到字符串 - :010F00000010E0

                //成功执行读命令，结果值：12320
                //(COM1)发送字符串 - :010100000010EE
                //(COM1)收到字符串 - :0101022030AC

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01850179  -- 写从站线圈失败后，

                    //    //(COM1)收到字符串 - :01050000FF00FB  -- 成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                    //    //3A 30 31 30 46 30 30 30 30 30 30 30 31 45 46 0D 0A
                    //    // :018F036D\r\n

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))
                        //sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        //  ok-ok
        /// <summary>
        /// 写从站N个字的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置N个字线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilWord(byte DeviceAddress, ushort BeginAddress, ushort[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                //if (SetValue.Length * 2 * 8 > 1968)
                //{
                //    throw new Exception("设置值byte[]数组的长度超出范围(1~123)，请修改参数数组的长度");
                //}

                if (BeginAddress + SetValue.Length * 2 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes2To4HexStr(CConverter.ToBytes(SetValue, WriteCoilBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, SetValue.Length * 2 * 8, SetValue.Length * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = SetValue.Length * 2 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(SetValue.Length * 2);//N - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //for (int i = 0; i < SetValue.Length; i++)
                //{
                //    //sCmdToCalcLRC += SetValue[i].ToString("X4");

                //    byte[] byTemp = BitConverter.GetBytes(SetValue[i]);
                //    sCmdToCalcLRC += byTemp[0].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[1].ToString("X2");// 数据设置值 - 低字节
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //发送值[0~1]：-455 -32647 
                //成功执行写命令
                //写操作记录：(COM1)发送字符串 - :010F000000200439FE79809C
                //写操作记录：(COM1)收到字符串 - :010F00000020D0

                //成功执行读命令，结果值：-455 -32647 
                //(COM1)发送字符串 - :010100000020DE
                //(COM1)收到字符串 - :01010439FE7980CA

                //发送值[0~1]：-4316 24771
                //写操作记录：(COM1)发送字符串 - :010F000000200424EFC36096
                //写操作记录：(COM1)收到字符串 - :010F00000020D0

                //成功执行读命令，结果值：-4316 24771 
                //(COM1)发送字符串 - :010100000020DE
                //(COM1)收到字符串 - :01010424EFC360C4

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01850179  -- 写从站线圈失败后，

                    //    //(COM1)发送字符串 - :01050000FF00FB
                    //    //(COM1)收到字符串 - :01050000FF00FB  -- 成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                    //    //3A 30 31 30 46 30 30 30 30 30 30 30 31 45 46 0D 0A
                    //    // :018F036D\r\n

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))//sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站1个双字的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置1个双字线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilWord(byte DeviceAddress, ushort BeginAddress, int SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress + 4 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes4To8HexStr(CConverter.ToBytes(SetValue, WriteCoilBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, 4 * 8, 4, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = 4 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = 4;// Convert.ToByte(iDataLength / 8);//4 - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //byte[] byTemp = BitConverter.GetBytes(SetValue);
                //sCmdToCalcLRC += byTemp[0].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[1].ToString("X2");// 数据设置值 - 低字节
                //sCmdToCalcLRC += byTemp[2].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[3].ToString("X2");// 数据设置值 - 低字节

                ////byte[] byDataLength = IntToHex(1);//数据长度(4个字符)
                ////sCmdToCalcLRC += byDataLength[0].ToString("X2");
                ////sCmdToCalcLRC += byDataLength[1].ToString("X2");

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))
                        //sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站N个双字的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置N个双字线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilWord(byte DeviceAddress, ushort BeginAddress, int[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                //if (SetValue.Length * 4 * 8 > 1968)
                //{
                //    throw new Exception("设置值byte[]数组的长度超出范围(1~123)，请修改参数数组的长度");
                //}

                if (BeginAddress + SetValue.Length * 4 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes4To8HexStr(CConverter.ToBytes(SetValue, WriteCoilBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, SetValue.Length * 4 * 8, SetValue.Length * 4, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = SetValue.Length * 4 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(SetValue.Length * 4);//N - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //for (int i = 0; i < SetValue.Length; i++)
                //{
                //    //sCmdToCalcLRC += SetValue[i].ToString("X4");

                //    byte[] byTemp = BitConverter.GetBytes(SetValue[i]);
                //    sCmdToCalcLRC += byTemp[0].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[1].ToString("X2");// 数据设置值 - 低字节
                //    sCmdToCalcLRC += byTemp[2].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[3].ToString("X2");// 数据设置值 - 低字节
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"



                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))//sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站1个双字的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置1个双字线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilWord(byte DeviceAddress, ushort BeginAddress, uint SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress + 4 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes4To8HexStr(CConverter.ToBytes(SetValue, WriteCoilBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, 4 * 8, 4, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = 4 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = 4;// Convert.ToByte(iDataLength / 8);//4 - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //byte[] byTemp = BitConverter.GetBytes(SetValue);
                //sCmdToCalcLRC += byTemp[0].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[1].ToString("X2");// 数据设置值 - 低字节
                //sCmdToCalcLRC += byTemp[2].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[3].ToString("X2");// 数据设置值 - 低字节

                ////byte[] byDataLength = IntToHex(1);//数据长度(4个字符)
                ////sCmdToCalcLRC += byDataLength[0].ToString("X2");
                ////sCmdToCalcLRC += byDataLength[1].ToString("X2");

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))
                        //sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站N个双字的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置N个双字线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilWord(byte DeviceAddress, ushort BeginAddress, uint[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                //if (SetValue.Length * 4 * 8 > 1968)
                //{
                //    throw new Exception("设置值byte[]数组的长度超出范围(1~123)，请修改参数数组的长度");
                //}

                if (BeginAddress + SetValue.Length * 4 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes4To8HexStr(CConverter.ToBytes(SetValue, WriteCoilBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, SetValue.Length * 4 * 8, SetValue.Length * 4, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = SetValue.Length * 4 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(SetValue.Length * 4);//N - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //for (int i = 0; i < SetValue.Length; i++)
                //{
                //    //sCmdToCalcLRC += SetValue[i].ToString("X4");

                //    byte[] byTemp = BitConverter.GetBytes(SetValue[i]);
                //    sCmdToCalcLRC += byTemp[0].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[1].ToString("X2");// 数据设置值 - 低字节
                //    sCmdToCalcLRC += byTemp[2].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[3].ToString("X2");// 数据设置值 - 低字节
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"



                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))//sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站2个双字的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置2个双字线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilWord(byte DeviceAddress, ushort BeginAddress, long SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress + 8 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes8To16HexStr(CConverter.ToBytes(SetValue, WriteCoilBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, 8 * 8, 8, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = 8 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = 8;//8 - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //byte[] byTemp = BitConverter.GetBytes(SetValue);
                //sCmdToCalcLRC += byTemp[0].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[1].ToString("X2");// 数据设置值 - 低字节
                //sCmdToCalcLRC += byTemp[2].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[3].ToString("X2");// 数据设置值 - 低字节
                //sCmdToCalcLRC += byTemp[4].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[5].ToString("X2");// 数据设置值 - 低字节
                //sCmdToCalcLRC += byTemp[6].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[7].ToString("X2");// 数据设置值 - 低字节

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))
                        //sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站N个2个双字的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置N个2个双字线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilWord(byte DeviceAddress, ushort BeginAddress, long[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                //if (SetValue.Length * 8 * 8 > 1968)
                //{
                //    throw new Exception("设置值byte[]数组的长度超出范围(1~123)，请修改参数数组的长度");
                //}

                if (BeginAddress + SetValue.Length * 8 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes8To16HexStr(CConverter.ToBytes(SetValue, WriteCoilBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, SetValue.Length * 8 * 8, SetValue.Length * 8, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = SetValue.Length * 8 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(SetValue.Length * 8);//N - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //for (int i = 0; i < SetValue.Length; i++)
                //{
                //    //sCmdToCalcLRC += SetValue[i].ToString("X4");

                //    byte[] byTemp = BitConverter.GetBytes(SetValue[i]);
                //    sCmdToCalcLRC += byTemp[0].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[1].ToString("X2");// 数据设置值 - 低字节
                //    sCmdToCalcLRC += byTemp[2].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[3].ToString("X2");// 数据设置值 - 低字节
                //    sCmdToCalcLRC += byTemp[4].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[5].ToString("X2");// 数据设置值 - 低字节
                //    sCmdToCalcLRC += byTemp[6].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[7].ToString("X2");// 数据设置值 - 低字节
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"



                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))//sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站2个双字的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置2个双字线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilWord(byte DeviceAddress, ushort BeginAddress, ulong SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress + 8 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes8To16HexStr(CConverter.ToBytes(SetValue, WriteCoilBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, 8 * 8, 8, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = 8 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = 8;//8 - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //byte[] byTemp = BitConverter.GetBytes(SetValue);
                //sCmdToCalcLRC += byTemp[0].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[1].ToString("X2");// 数据设置值 - 低字节
                //sCmdToCalcLRC += byTemp[2].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[3].ToString("X2");// 数据设置值 - 低字节
                //sCmdToCalcLRC += byTemp[4].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[5].ToString("X2");// 数据设置值 - 低字节
                //sCmdToCalcLRC += byTemp[6].ToString("X2");// 数据设置值 - 高字节
                //sCmdToCalcLRC += byTemp[7].ToString("X2");// 数据设置值 - 低字节

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))
                        //sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站N个2个双字的线圈
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="SetValue">设置N个2个双字线圈的当前值</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteCoilWord(byte DeviceAddress, ushort BeginAddress, ulong[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                //if (SetValue.Length * 8 * 8 > 1968)
                //{
                //    throw new Exception("设置值byte[]数组的长度超出范围(1~123)，请修改参数数组的长度");
                //}

                if (BeginAddress + SetValue.Length * 8 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes8To16HexStr(CConverter.ToBytes(SetValue, WriteCoilBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiCoil, BeginAddress, SetValue.Length * 8 * 8, SetValue.Length * 8, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据位长度 - 位的数据长度
                //int iDataLength = SetValue.Length * 8 * 8;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(SetValue.Length * 8);//N - 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                //// 线圈值的设置
                //for (int i = 0; i < SetValue.Length; i++)
                //{
                //    //sCmdToCalcLRC += SetValue[i].ToString("X4");

                //    byte[] byTemp = BitConverter.GetBytes(SetValue[i]);
                //    sCmdToCalcLRC += byTemp[0].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[1].ToString("X2");// 数据设置值 - 低字节
                //    sCmdToCalcLRC += byTemp[2].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[3].ToString("X2");// 数据设置值 - 低字节
                //    sCmdToCalcLRC += byTemp[4].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[5].ToString("X2");// 数据设置值 - 低字节
                //    sCmdToCalcLRC += byTemp[6].ToString("X2");// 数据设置值 - 高字节
                //    sCmdToCalcLRC += byTemp[7].ToString("X2");// 数据设置值 - 低字节
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"



                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 5

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0F

                    //    string sCmd = CModbusFuncCode.WriteMultiCoil.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//CModbusFunctionCode.WriteMultiCoil.ToString()[0]       :010F
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        // *** 写从站多个线圈失败后
                        //写操作记录：(COM1)收到字符串 - :018F036D

                        // *** 成功写从站多个线圈后，从站返回的字符串内容与发送的字符串内容，前面 13 个字符相同

                        //string sFront13CharsOfSentCmd = Strings.Mid(sCmdDataToBeSent, 1, 13);

                        if (Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2) == CModbusFuncCode.WriteMultiCoil.ToString("X2"))//sFeedBackFromSlave[3] == '0' && sFeedBackFromSlave[4] == 'F'
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        #endregion

        #region "写单个/多个保持寄存器 - ok-ok"

        // ok-ok
        /// <summary>
        /// 写从站单个保持寄存器的值(short:  -32,768 到 32,767)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置单个保持寄存器的值(short:  -32,768 到 32,767)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, short SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 2 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //06 - 设置单个保持寄存器(short:  -32,768 到 32,767)
                //:         地址码         功能码    设置起始地址   设置值      LRC     回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符    2字符

                // 求 LRC -- 设备地址(2个字符) + 功能码(2个字符) + 起始地址(4个字符) + 数据值(4个字符)

                //string sTemp = SetValue.ToString("X4");
                //string sData = CConverter.Reorder2HexStrData(sTemp, WriteKeepRegisterBytesFormat);
                string sData = CConverter.Bytes2To4HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));

                byte[] byResult = PackSingleWriteCmd(DeviceAddress, ModbusFuncCode.WriteRegister, BeginAddress, sData);

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////设置值
                //sCmdToCalcLRC += SetValue.ToString("X4");

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

    string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //写从站线圈失败后，

                //成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                //成功执行写命令-4609
                //写操作记录：(COM1)发送字符串 - :01060000EDFF0D
                //写操作记录：(COM1)收到字符串 - :01060000EDFF0D

                //成功执行写命令-5159
                //写操作记录：(COM1)发送字符串 - :01060000EBD935
                //写操作记录：(COM1)收到字符串 - :01060000EBD935

                //成功执行写命令20116
                //写操作记录：(COM1)发送字符串 - :010600004E9417
                //写操作记录：(COM1)收到字符串 - :010600004E9417

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 6

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 6

                    //    string sCmd = CModbusFuncCode.WriteRegister.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//:0106
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0106
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站多个保持寄存器的值(short:  -32,768 到 32,767)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置多个保持寄存器的值(short:  -32,768 到 32,767)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, short[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (SetValue.Length * 2 * 8 > 1968)
                //{
                //    throw new Exception("设置值byte[]数组的长度超出范围(1~123)，请修改参数数组的长度");
                //}

                if (BeginAddress + SetValue.Length * 2 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节
                //short:  -32,768 到 32,767

                string sData = CConverter.Bytes2To4HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));
                //short[] stData = CConverter.ToInt16Array(CConverter.ToBytes(SetValue));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, SetValue.Length, SetValue.Length * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据字长度 - 字数据的长度
                //int iDataLength = SetValue.Length;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//数组长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //for (int i = 0; i < SetValue.Length; i++)
                //{
                //    sCmdToCalcLRC += SetValue[i].ToString("X4");
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //写从站线圈失败后，

                //成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                //发送值[0~9]：1761 -14407 5777 5774 16502 17463 1001 -19511 27348 -21393
                //写操作记录：(COM1)发送字符串 - :01100000000A1406E1C7B91691168E4076443703E9B3C96AD4AC6F2D
                //写操作记录：(COM1)收到字符串 - :01100000000AE5

                //发送值[0~9]：26335 23829 -26550 24597 3427 29150 31561 3617 -19622 10699
                //写操作记录：(COM1)发送字符串 - :01100000000A1466DF5D15984A60150D6371DE7B490E21B35A29CB10
                //写操作记录：(COM1)收到字符串 - :01100000000AE5

                //发送值[0~9]：-17156 6028 12968 -24273 -21261 25743 -18234 -5990 5811 -10245
                //写操作记录：(COM1)发送字符串 - :01100000000A14BCFC178C32A8A12FACF3648FB8C6E89A16B3D7FB9F
                //写操作记录：(COM1)收到字符串 - :01100000000AE5

                //发送值[0~9]：-17884 -22043 -19558 6775 1968 -28626 10138 -25864 9493 29086
                //写操作记录：(COM1)发送字符串 - :01100000000A14BA24A9E5B39A1A7707B0902E279A9AF82515719E76
                //写操作记录：(COM1)收到字符串 - :01100000000AE5

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 6

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {


                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站单个保持寄存器的值(ushort:  0 到 65535)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置单个保持寄存器的值(ushort:  0 到 65535)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, ushort SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 2 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //06 - 设置单个保持寄存器(short:  -32,768 到 32,767)
                //:         地址码         功能码    设置起始地址   设置值      LRC     回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符    2字符

                //string sTemp = SetValue.ToString("X4");
                //string sData = CConverter.Reorder2HexStrData(sTemp, WriteKeepRegisterBytesFormat);
                string sData = CConverter.Bytes2To4HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));

                byte[] byResult = PackSingleWriteCmd(DeviceAddress, ModbusFuncCode.WriteRegister, BeginAddress, sData);

                #region "Old codes -- No use"

                //// 求 LRC -- 设备地址(2个字符) + 功能码(2个字符) + 起始地址(4个字符) + 数据值(4个字符)
                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////设置值
                //sCmdToCalcLRC += SetValue.ToString("X4");

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //写从站线圈失败后，

                //成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                //成功执行写命令-4609
                //写操作记录：(COM1)发送字符串 - :01060000EDFF0D
                //写操作记录：(COM1)收到字符串 - :01060000EDFF0D

                //成功执行写命令-5159
                //写操作记录：(COM1)发送字符串 - :01060000EBD935
                //写操作记录：(COM1)收到字符串 - :01060000EBD935

                //成功执行写命令20116
                //写操作记录：(COM1)发送字符串 - :010600004E9417
                //写操作记录：(COM1)收到字符串 - :010600004E9417

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 6

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 0
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 6

                    //    string sCmd = CModbusFuncCode.WriteRegister.ToString("X2");

                    //    if (cByte3 == 0x0.ToString()[0] && cByte4 == sCmd[1])//:0106
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0106
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写从站多个保持寄存器的值(ushort:  0 到 65535)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置多个保持寄存器的值(ushort:  0 到 65535)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, ushort[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                //if (SetValue.Length * 2 * 8 > 1968)
                //{
                //    throw new Exception("设置值byte[]数组的长度超出范围(1~123)，请修改参数数组的长度");
                //}

                if (BeginAddress + SetValue.Length * 2 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节
                //short:  -32,768 到 32,767

                string sData = CConverter.Bytes2To4HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, SetValue.Length, SetValue.Length * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据字长度 - 字数据的长度
                //int iDataLength = SetValue.Length;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//数组长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //for (int i = 0; i < SetValue.Length; i++)
                //{
                //    sCmdToCalcLRC += SetValue[i].ToString("X4");
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //写从站线圈失败后，

                //成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                //发送值[0~9]：1761 -14407 5777 5774 16502 17463 1001 -19511 27348 -21393
                //写操作记录：(COM1)发送字符串 - :01100000000A1406E1C7B91691168E4076443703E9B3C96AD4AC6F2D
                //写操作记录：(COM1)收到字符串 - :01100000000AE5

                //发送值[0~9]：26335 23829 -26550 24597 3427 29150 31561 3617 -19622 10699
                //写操作记录：(COM1)发送字符串 - :01100000000A1466DF5D15984A60150D6371DE7B490E21B35A29CB10
                //写操作记录：(COM1)收到字符串 - :01100000000AE5

                //发送值[0~9]：-17156 6028 12968 -24273 -21261 25743 -18234 -5990 5811 -10245
                //写操作记录：(COM1)发送字符串 - :01100000000A14BCFC178C32A8A12FACF3648FB8C6E89A16B3D7FB9F
                //写操作记录：(COM1)收到字符串 - :01100000000AE5

                //发送值[0~9]：-17884 -22043 -19558 6775 1968 -28626 10138 -25864 9493 29086
                //写操作记录：(COM1)发送字符串 - :01100000000A14BA24A9E5B39A1A7707B0902E279A9AF82515719E76
                //写操作记录：(COM1)收到字符串 - :01100000000AE5

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    #region "通讯记录"

                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    //**********************
                    //    //首字符
                    //    //[0] - :

                    //    //从站地址
                    //    //[1] - 0
                    //    //[2] - 1

                    //    //读取成功的功能码
                    //    //[3] - 0
                    //    //[4] - 6

                    //    //读取失败的错误码
                    //    //[3] - 0
                    //    //[4] - 8
                    //    //**********************

                    //    #endregion

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {


                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus Ascii(" + RS232CPort.PortName + ")通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写int((-2,147,483,648 到 2,147,483,647, 有符号, 32 位整数)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置保持寄存器的值(int)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, int SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 4 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                //byte[] byBytes = CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat);
                //string sHex = CConverter.Bytes4To8HexStr(byBytes);

                string sData = CConverter.Bytes4To8HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, 2, 4, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据字长度 - 字数据的长度
                //int iDataLength = 2;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //byte[] byFloatToBytes = BitConverter.GetBytes(SetValue);
                //for (int i = 0; i < byFloatToBytes.Length / 2; i++)
                //{
                //    sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
                //    sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 6

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //成功执行写命令8184.571
                //写操作记录：(COM1)发送字符串 - :01100000000204C49245FF4F

                //写操作记录：(COM1)收到字符串 - :011000000002ED

                //成功执行写命令2654
                //写操作记录：(COM1)发送字符串 - :01100000000204E00045259F

                //写操作记录：(COM1)收到字符串 - :011000000002ED

                //成功执行写命令-3837.714
                //写操作记录：(COM1)发送字符串 - :01100000000204DB6EC56F6C

                //写操作记录：(COM1)收到字符串 - :011000000002ED

                //成功执行写命令2093.428
                //写操作记录：(COM1)发送字符串 - :01100000000204D6DB4502F1

                //写操作记录：(COM1)收到字符串 - :011000000002ED

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus RTU通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写int(-2,147,483,648 到 2,147,483,647, 有符号, 32 位整数)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置保持寄存器的值(int)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, int[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + SetValue.Length * 4 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes4To8HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, SetValue.Length * 2, SetValue.Length * 2 * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据字长度 - 字数据的长度
                //int iDataLength = SetValue.Length * 2;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //for (int j = 0; j < SetValue.Length; j++)
                //{
                //    byte[] byFloatToBytes = BitConverter.GetBytes(SetValue[j]);
                //    for (int i = 0; i < byFloatToBytes.Length / 2; i++)
                //    {
                //        sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
                //        sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
                //    }
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 6

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus RTU通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写uint(0 到 4,294,967,295)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置保持寄存器的值(uint)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, uint SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 4 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes4To8HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, 2, 2 * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据字长度 - 字数据的长度
                //int iDataLength = 2;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //byte[] byFloatToBytes = BitConverter.GetBytes(SetValue);
                //for (int i = 0; i < byFloatToBytes.Length / 2; i++)
                //{
                //    sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
                //    sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 6

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //成功执行写命令8184.571
                //写操作记录：(COM1)发送字符串 - :01100000000204C49245FF4F

                //写操作记录：(COM1)收到字符串 - :011000000002ED

                //成功执行写命令2654
                //写操作记录：(COM1)发送字符串 - :01100000000204E00045259F

                //写操作记录：(COM1)收到字符串 - :011000000002ED

                //成功执行写命令-3837.714
                //写操作记录：(COM1)发送字符串 - :01100000000204DB6EC56F6C

                //写操作记录：(COM1)收到字符串 - :011000000002ED

                //成功执行写命令2093.428
                //写操作记录：(COM1)发送字符串 - :01100000000204D6DB4502F1

                //写操作记录：(COM1)收到字符串 - :011000000002ED

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus RTU通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写uint(0 到 4,294,967,295)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置保持寄存器的值(uint)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, uint[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + SetValue.Length * 4 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

                string sData = CConverter.Bytes4To8HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, SetValue.Length * 2, SetValue.Length * 2 * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////数据字长度 - 字数据的长度
                //int iDataLength = SetValue.Length * 2;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //for (int j = 0; j < SetValue.Length; j++)
                //{
                //    byte[] byFloatToBytes = BitConverter.GetBytes(SetValue[j]);
                //    for (int i = 0; i < byFloatToBytes.Length / 2; i++)
                //    {
                //        sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
                //        sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
                //    }
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 6

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************



                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus RTU通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写float(32位浮点值)值到从站保持寄存器(float  -3.4×10的38次方 到 +3.4×10的38次方, 精度：7 位)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置保持寄存器的值(float)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, float SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 4 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节
                //short:  -32,768 到 32,767

                //设置值
                string sData = "";
                //byte[] byFloatToBytes = BitConverter.GetBytes(SetValue);
                //for (int i = 0; i < byFloatToBytes.Length / 2; i++)
                //{
                //    sData += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
                //    sData += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
                //}

                sData = CConverter.Bytes4To8HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));//格式错误，无法与其它同类型写保持寄存器使用这个WriteKeepRegisterBytesFormat参数
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, 2, 4, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////float = 2个short，所以这里转换为字节数量：2 * 2
                ////数据字长度 - 字数据的长度
                //int iDataLength = 2;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //byte[] byFloatToBytes = BitConverter.GetBytes(SetValue);
                //for (int i = 0; i < byFloatToBytes.Length / 2; i++)
                //{
                //    sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
                //    sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 6

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //成功执行写命令8184.571
                //写操作记录：(COM1)发送字符串 - :01100000000204C49245FF4F

                //写操作记录：(COM1)收到字符串 - :011000000002ED

                //成功执行写命令2654
                //写操作记录：(COM1)发送字符串 - :01100000000204E00045259F

                //写操作记录：(COM1)收到字符串 - :011000000002ED

                //成功执行写命令-3837.714
                //写操作记录：(COM1)发送字符串 - :01100000000204DB6EC56F6C

                //写操作记录：(COM1)收到字符串 - :011000000002ED

                //成功执行写命令2093.428
                //写操作记录：(COM1)发送字符串 - :01100000000204D6DB4502F1

                //写操作记录：(COM1)收到字符串 - :011000000002ED

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus RTU通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写float(32位浮点值)值到从站保持寄存器(float  -3.4×10的38次方 到 +3.4×10的38次方, 精度：7 位)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置保持寄存器的值(float)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, float[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + SetValue.Length * 4 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节
                //short:  -32,768 到 32,767

                string sData = CConverter.Bytes4To8HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, SetValue.Length * 2, SetValue.Length * 2 * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////float = 2个short，所以这里转换为字节数量：2 * 2
                ////数据字长度 - 字数据的长度
                //int iDataLength = SetValue.Length * 2;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //for (int j = 0; j < SetValue.Length; j++)
                //{
                //    byte[] byFloatToBytes = BitConverter.GetBytes(SetValue[j]);
                //    for (int i = 0; i < byFloatToBytes.Length / 2; i++)
                //    {
                //        sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
                //        sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
                //    }
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 6

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //发送值[0~3]：6611.714 -8570.571 4602.571 -5777.714 
                //成功执行写命令
                //写操作记录：(COM1)发送字符串 - :011000000008109DB745CEEA49C605D492458F8DB7C5B47B

                //写操作记录：(COM1)收到字符串 - :011000000008E7

                //发送值[0~3]：-9180 -1506.571 2436 -6548 
                //成功执行写命令
                //写操作记录：(COM1)发送字符串 - :011000000008107000C60F5249C4BC40004518A000C5CCA9

                //写操作记录：(COM1)收到字符串 - :011000000008E7

                //发送值[0~3]：-234.5714 -2424 8976.571 2919.714 
                //成功执行写命令
                //写操作记录：(COM1)发送字符串 - :011000000008109249C36A8000C5174249460C7B6E453632

                //写操作记录：(COM1)收到字符串 - :011000000008E7

                //发送值[0~3]：-1406.857 3498.857 -8491.429 -1091.143 
                //成功执行写命令
                //写操作记录：(COM1)发送字符串 - :01100000000810DB6EC4AFADB7455AADB7C6046492C488A8

                //写操作记录：(COM1)收到字符串 - :011000000008E7

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus RTU通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写double(64位浮点值)值到从站保持寄存器(±5.0×10的−324次方 到 ±1.7×10的308次方   精度:15到16位)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置保持寄存器的值(double)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, double SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 8 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节
                //short:  -32,768 到 32,767

                string sData = CConverter.Bytes8To16HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, 4, 4 * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////double = 4个short，所以这里转换为字节数量：4 * 2
                ////数据字长度 - 字数据的长度
                //int iDataLength = 4;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //byte[] byFloatToBytes = BitConverter.GetBytes(SetValue);
                //for (int i = 0; i < byFloatToBytes.Length / 2; i++)
                //{
                //    sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
                //    sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //写从站线圈失败后，

                //成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 6

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //成功执行写命令-603.142857142857
                //写操作记录：(COM1)发送字符串 - :0110000000040824929249D924C08213
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行写命令-5564.28571428571
                //写操作记录：(COM1)发送字符串 - :0110000000040849252492BC49C0B545
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行写命令7798.57142857143
                //写操作记录：(COM1)发送字符串 - :0110000000040892494924769240BE95
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行写命令-7428.28571428571
                //写操作记录：(COM1)发送字符串 - :01100000000408492524920449C0BDF5
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行写命令-7319.42857142857
                //写操作记录：(COM1)发送字符串 - :011000000004086DB7B6DB976DC0BCAE
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus RTU通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写double(64位浮点值)值到从站保持寄存器(±5.0×10的−324次方 到 ±1.7×10的308次方   精度:15到16位)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置保持寄存器的值(double)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, double[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + SetValue.Length * 8 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节
                //short:  -32,768 到 32,767

                string sData = CConverter.Bytes8To16HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, SetValue.Length * 4, SetValue.Length * 4 * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////double = 4个short，所以这里转换为字节数量：4 * 2
                ////数据字长度 - 字数据的长度
                //int iDataLength = SetValue.Length * 4;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //for (int j = 0; j < SetValue.Length; j++)
                //{
                //    byte[] byFloatToBytes = BitConverter.GetBytes(SetValue[j]);
                //    for (int i = 0; i < byFloatToBytes.Length / 2; i++)
                //    {
                //        sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
                //        sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
                //    }
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //写从站线圈失败后，

                //成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 6

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //发送值[0~3]：-6803.14306640625 -4078.57153320313 -5290.85693359375 -3673.42846679688
                //写操作记录：(COM1)发送字符串 - :011000000010200000A0009324C0BA0000A000DD24C0AF00006000AADBC0B400006000B2DBC0AC2C
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //发送值[0~3]：8971.7138671875 -6616.85693359375 8470.5712890625 -766.285705566406
                //写操作记录：(COM1)发送字符串 - :011000000010200000600085DB40C100006000D8DBC0B9000020008B4940C000002000F249C087DC
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //发送值[0~3]：-2275.14282226563 7505.71435546875 -6846.28564453125 1870.57141113281
                //写操作记录：(COM1)发送字符串 - :0110000000102000002000C649C0A10000E00051B640BD00002000BE49C0BA000020003A49409D2A
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus RTU通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写long(64位整数值)值到从站保持寄存器(-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807, 有符号 64 位整数)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置保持寄存器的值(long)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, long SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 8 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节
                //short:  -32,768 到 32,767

                string sData = CConverter.Bytes8To16HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, 4, 4 * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////double = 4个short，所以这里转换为字节数量：4 * 2
                ////数据字长度 - 字数据的长度
                //int iDataLength = 4;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //byte[] byFloatToBytes = BitConverter.GetBytes(SetValue);
                //for (int i = 0; i < byFloatToBytes.Length / 2; i++)
                //{
                //    sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
                //    sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //写从站线圈失败后，

                //成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 6

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //成功执行写命令-1679369208
                //写操作记录：(COM1)发送字符串 - :01100000000408DC089BE6FFFFFFFF82
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行写命令-232922630
                //写操作记录：(COM1)发送字符串 - :01100000000408E1FAF21DFFFFFFFFFD
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行写命令1321247723
                //写操作记录：(COM1)发送字符串 - :01100000000408A3EB4EC00000000047
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行写命令-1253068578
                //写操作记录：(COM1)发送字符串 - :01100000000408B0DEB54FFFFFFFFF55
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus RTU通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写long(64位整数值)值到从站保持寄存器(-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807, 有符号 64 位整数)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置保持寄存器的值(long)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, long[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + SetValue.Length * 8 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节
                //short:  -32,768 到 32,767

                string sData = CConverter.Bytes8To16HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, SetValue.Length * 4, SetValue.Length * 4 * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////double = 4个short，所以这里转换为字节数量：4 * 2
                ////数据字长度 - 字数据的长度
                //int iDataLength = SetValue.Length * 4;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //for (int j = 0; j < SetValue.Length; j++)
                //{
                //    byte[] byFloatToBytes = BitConverter.GetBytes(SetValue[j]);
                //    for (int i = 0; i < byFloatToBytes.Length / 2; i++)
                //    {
                //        sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
                //        sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
                //    }
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //写从站线圈失败后，

                //成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 6

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //发送值[0~3]：-1463375088 879789444 1723001098 -963809514
                //写操作记录：(COM1)发送字符串 - :01100000001020AB10A8C6FFFFFFFF8584347000000000E90A66B2000000006F16C68DFFFFFFFF0E
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //发送值[0~3]：1021952288 -579563780 -1379586892 18051368
                //写操作记录：(COM1)发送字符串 - :01100000001020C1203CE9000000008EFCDD74FFFFFFFF2CB4ADC5FFFFFFFF7128011300000000E7
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //发送值[0~3]：1874326609 1742260251 -629622734 -337371585
                //写操作记录：(COM1)发送字符串 - :01100000001020F4516FB700000000C81B67D800000000B832DA78FFFFFFFF1E3FEBE4FFFFFFFFD2
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus RTU通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写ulong(64位无符号整数值)值到从站保持寄存器(0 到 18,446,744,073,709,551,615)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置保持寄存器的值(ulong)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, ulong SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + 8 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节
                //short:  -32,768 到 32,767

                string sData = CConverter.Bytes8To16HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, 4, 4 * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////double = 4个short，所以这里转换为字节数量：4 * 2
                ////数据字长度 - 字数据的长度
                //int iDataLength = 4;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //byte[] byFloatToBytes = BitConverter.GetBytes(SetValue);
                //for (int i = 0; i < byFloatToBytes.Length / 2; i++)
                //{
                //    sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
                //    sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //写从站线圈失败后，

                //成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 6

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //成功执行写命令-1679369208
                //写操作记录：(COM1)发送字符串 - :01100000000408DC089BE6FFFFFFFF82
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行写命令-232922630
                //写操作记录：(COM1)发送字符串 - :01100000000408E1FAF21DFFFFFFFFFD
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行写命令1321247723
                //写操作记录：(COM1)发送字符串 - :01100000000408A3EB4EC00000000047
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                //成功执行写命令-1253068578
                //写操作记录：(COM1)发送字符串 - :01100000000408B0DEB54FFFFFFFFF55
                //写操作记录：(COM1)收到字符串 - :011000000004EB

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus RTU通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        // ok-ok
        /// <summary>
        /// 写ulong(64位无符号整数值)值到从站保持寄存器(0 到 18,446,744,073,709,551,615)
        /// </summary>
        /// <param name="DeviceAddress">从站设备地址</param>
        /// <param name="BeginAddress">读取起始地址</param>
        /// <param name="SetValue">设置保持寄存器的值(ulong)</param>
        /// <returns>是否成功执行命令</returns>
        public bool WriteKeepRegister(byte DeviceAddress, ushort BeginAddress, ulong[] SetValue)
        {
            try
            {
                if (null == RS232CPort || RS232CPort.IsOpen == false)
                {
                    return false;
                }

                if (null == SetValue || SetValue.Length < 1)
                {
                    throw new Exception("设置值数组不能为空");
                }

                if (BeginAddress < 0 || BeginAddress > 65535)//读取数据长度，有效值范围：1~2000(位)
                {
                    throw new Exception("起始地址的值不正确，有效值范围：0~65535(位)");
                }

                if (BeginAddress + SetValue.Length * 8 * 8 > 65535)
                {
                    throw new Exception("起始地址加设置值的长度超出寻址范围，请修改起始地址或参数数组的长度");
                }

                //10(16) - 设置多个保持寄存器
                //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
                //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
                //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节
                //short:  -32,768 到 32,767

                string sData = CConverter.Bytes8To16HexStr(CConverter.ToBytes(SetValue, WriteKeepRegisterBytesFormat));
                byte[] byResult = PackMultiWriteCmd(DeviceAddress, ModbusFuncCode.WriteMultiRegister, BeginAddress, SetValue.Length * 4, SetValue.Length * 4 * 2, sData);
                if (null == byResult)
                {
                    return false;
                }

                #region "Old codes -- No use"

                //string sCmdToCalcLRC = "";
                //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
                //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

                //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
                //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
                //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

                ////double = 4个short，所以这里转换为字节数量：4 * 2
                ////数据字长度 - 字数据的长度
                //int iDataLength = SetValue.Length * 4;
                //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
                //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
                //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

                //// 字节计数
                //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
                //sCmdToCalcLRC += byByteCount.ToString("X2");

                ////设置值
                //for (int j = 0; j < SetValue.Length; j++)
                //{
                //    byte[] byFloatToBytes = BitConverter.GetBytes(SetValue[j]);
                //    for (int i = 0; i < byFloatToBytes.Length / 2; i++)
                //    {
                //        sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
                //        sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
                //    }
                //}

                //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

                //sCmdToCalcLRC = null;

                ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

                #endregion

                string sFeedBackFromSlave = WriteAndReadBytes(byResult, DeviceAddress); //byte[] byReadData =  WriteAndReadBytes(byResult, DeviceAddress);//, sCmdDataToBeSent);

                if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)//if (null == byReadData)
                {
                    return false;
                }

                #region "Old codes - No use"

                //if (bSaveSendStringToLog == true)//&& ProcessFeedbackDataByBytes == false
                //{
                //    sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                //    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                //}

                //Lock();

                ////清除发送前的接收缓冲区
                //ClearReceiveBuffer();

                //// 通过串口发送指令数据给客户端
                //RS232CPort.Write(byResult, 0, byResult.Length);

                //byResult = null;

                //// 读取客户端的返回信息
                //Stopwatch swUsedTime = new Stopwatch();
                //swUsedTime.Restart();

                //while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                //{
                //    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                //    {
                //        Unlock();
                //        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                //        //break;
                //    }

                //    //Application.DoEvents();
                //    System.Threading.Thread.Sleep(iSleepTime);
                //}

                //byte[] byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());

                //Unlock();

                #endregion

                // string sFeedBackFromSlave = Encoding.ASCII.GetString(byReadData);

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字符串 - " + sFeedBackFromSlave);
                    }
                }

                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    return false;
                }

                #region "通讯记录"

                //写从站线圈失败后，

                //成功写从站后，从站返回的字符串内容与发送的字符串内容相同

                //**********************
                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 6

                //读取失败的错误码
                //[3] - 0
                //[4] - 8
                //**********************

                //发送值[0~3]：-1463375088 879789444 1723001098 -963809514
                //写操作记录：(COM1)发送字符串 - :01100000001020AB10A8C6FFFFFFFF8584347000000000E90A66B2000000006F16C68DFFFFFFFF0E
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //发送值[0~3]：1021952288 -579563780 -1379586892 18051368
                //写操作记录：(COM1)发送字符串 - :01100000001020C1203CE9000000008EFCDD74FFFFFFFF2CB4ADC5FFFFFFFF7128011300000000E7
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                //发送值[0~3]：1874326609 1742260251 -629622734 -337371585
                //写操作记录：(COM1)发送字符串 - :01100000001020F4516FB700000000C81B67D800000000B832DA78FFFFFFFF1E3FEBE4FFFFFFFFD2
                //写操作记录：(COM1)收到字符串 - :011000000010DF

                #endregion

                if (false)//ProcessFeedbackDataByBytes == true)
                {
                    #region "以字节方式处理从站的返回结果"

                    //sFeedBackFromSlave = null;

                    //if (null == byReadData || byReadData.Length < 2)
                    //{
                    //    return false;
                    //}
                    //else
                    //{
                    //    //string sTemp = BytesToHexStringSplitByChar(byReadData);

                    //    char cByte3 = Convert.ToChar(byReadData[3]);//功能码的第一个字节 - 1
                    //    char cByte4 = Convert.ToChar(byReadData[4]);//功能码的第一个字节 - 0

                    //    string sResultCmd = cByte3.ToString() + cByte4.ToString();
                    //    string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");

                    //    if (sResultCmd == sCmd)//:0106
                    //    //if (cByte3 == 0x0.ToString() && cByte4 == sCmd[1])//:0110
                    //    //if (sByte3 == 0x0.ToString("X2") && sByte4 == sCmd)//:0110
                    //    {
                    //    //byReadData = null;

                    //        return true;
                    //    }
                    //    else
                    //    {
                    //        AnalysisErrorCode(byReadData);
                    //        return false;
                    //    }
                    //}

                    #endregion
                }
                else
                {
                    #region "以字符串方式处理从站的返回结果"

                //byReadData = null;

                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == true)
                    {
                        return false;
                    }
                    else
                    {
                        //成功写从站后，从站返回的字符串内容与发送的字符串内容相同
                        string sFeedBack = Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2);
                        string sCmd = CModbusFuncCode.WriteMultiRegister.ToString("X2");
                        if (sFeedBack == sCmd)//sCmdDataToBeSent == sFeedBackFromSlave)
                        {
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return true;
                        }
                        else
                        {
                            AnalysisErrorCode(sFeedBackFromSlave);
                            //sCmdDataToBeSent = null;
                            sFeedBackFromSlave = null;

                            return false;
                        }
                    }

                    #endregion
                }
            }
            catch (Exception ex)
            {
                Enqueue(ex.Message + "  " + ex.StackTrace);
                if (ShowMessageDialog == true)
                {
                    //MessageBox.Show("Modbus RTU通讯时发生错误：\r\n" + ex.Message, "提示", //MessageBoxButtons.OK, //MessageBoxIcon.Information);
                }

                return false;
            }

            //return true;
        }

        #endregion

        #endregion

        #region "函数代码"

        #region "操作"

        /// <summary>
        /// 清除发送前的接收和发送缓冲区
        /// </summary>
        void ClearReceiveBuffer()
        {
            RS232CPort.DiscardInBuffer();
            RS232CPort.DiscardOutBuffer();
        }

        /// <summary>
        /// 出现线程锁异常时，用于执行强制清除线程锁
        /// </summary>
        /// <returns></returns>
        public bool ForceUnlock()
        {
            try
            {
                SyncLocker.Unlock();
            }
            catch (Exception)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// 锁定线程锁
        /// </summary>
        private void Lock()
        {
            if (bEnableThreadLock == true)
            {
                SyncLocker.Lock();
            }
        }

        /// <summary>
        /// 释放线程锁
        /// </summary>
        private void Unlock()
        {
            if (bEnableThreadLock == true || SyncLocker.IsLocked == true)
            {
                SyncLocker.Unlock();
            }
        }

        /// <summary>
        /// 释放资源
        /// </summary>
        public void Dispose()
        {
            bIsDisposing = true;

            //throw new NotImplementedException();
            Close();

            if (null != RS232CPort)
            {
                RS232CPort.Dispose();
                RS232CPort = null;
            }
        }

        /// <summary>
        /// 打开串口端口
        /// </summary>
        /// <returns></returns>
        public bool Open()
        {
            try
            {
                if (RS232CPort.IsOpen == false)
                {
                    RS232CPort.Open();
                }
            }
            catch (Exception)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// 关闭串口端口
        /// </summary>
        /// <returns></returns>
        public bool Close()
        {
            try
            {
                if (RS232CPort.IsOpen == true)
                {
                    RS232CPort.Close();
                }
            }
            catch (Exception)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// 保存信息到队列
        /// </summary>
        /// <param name="Msg">信息</param>
        /// <returns></returns>
        private bool Enqueue(string Msg)
        {
            try
            {
                if (string.IsNullOrEmpty(Msg) == true)
                {
                    return false;
                }

                if (qErrorMsg.Count < int.MaxValue)
                {
                    qErrorMsg.Enqueue("Modbus Ascii(" + RS232CPort.PortName + ")" + Msg);//发生错误
                }
                else
                {
                    qErrorMsg.Dequeue();
                    qErrorMsg.Enqueue("Modbus Ascii(" + RS232CPort.PortName + ")" + Msg);//发生错误
                }
            }
            catch (Exception)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// 获取通讯的记录信息
        /// </summary>
        /// <returns></returns>
        public string GetInfo()
        {
            try
            {
                if (qErrorMsg.Count > 0)
                {
                    return qErrorMsg.Dequeue();
                }
                else
                {
                    return "";
                }
            }
            catch (Exception)
            {
                return "";
            }
        }

        #endregion

        #region "换算、计算、处理"

        void RS232CPort_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            if (bReadSlaveDataOnly == false || bIsDisposing == true)
            {
                return;
            }

            try
            {
                //接收所有字节
                byte[] byReadData = new byte[RS232CPort.BytesToRead];
                RS232CPort.Read(byReadData, 0, byReadData.Length);

                qReceivedDataQueue.Enqueue(UnpackReceivedAsciiMsg(byReadData));
            }
            catch (Exception ex)
            {
                Enqueue("接收数据发生错误：" + ex.Message + "; " + ex.StackTrace);
            }
            
            #region "Old codes - No use"

            ////原始字符串、原始字节数组、从站地址、功能码、数据字符串/字节数组、日期和时间、是否CRC校验OK、是否LRC校验OK

            //CReadbackData gotData = new CReadbackData();
            //gotData.ReceivedDateTime = DateTime.Now;//UtcNow  日期和时间

            //try
            //{
            //    //接收所有字节
            //    byte[] byReadData = new byte[RS232CPort.BytesToRead];
            //    RS232CPort.Read(byReadData, 0, byReadData.Length);

            //    gotData.ReceivedBytes = byReadData;//原始字节数组

            //    //将字节数组转化为16进制字符串
            //    string sFeedBackFromSlave = CConverter.Bytes1To2HexStr(byReadData);
            //    gotData.ReceivedString = sFeedBackFromSlave;//原始字符串

            //    if (bSaveReceivedStringToLog == true)
            //    {
            //        if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
            //        {
            //            Enqueue("收到字节转换为16进制 - " + sFeedBackFromSlave);
            //        }
            //    }

            //    //计算LRC  是否LRC校验OK
            //    if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false) 
            //    {
            //        gotData.IsLRCOK = false;
            //        if (bSaveReceivedStringToLog == true)
            //        {
            //            Enqueue("错误 - 收到字节进行CRC校验时，收到的CRC码和计算的CRC码不匹配");
            //        }
            //    }
            //    else
            //    {
            //        gotData.IsLRCOK = true;
            //    }

            //    //首字符
            //    //[0] - :

            //    //从站地址
            //    //[1] - 0
            //    //[2] - 1

            //    //读取成功的功能码
            //    //[3] - 0
            //    //[4] - 1

            //    //读取失败的错误码
            //    //[3] - 0
            //    //[4] - 8

            //    gotData.SlaveAddress = Convert.ToByte(Strings.Mid(sFeedBackFromSlave, iPositionOfSlaveAddressCodeInReceivedString, 2));//从站地址

            //    gotData.FuncCode = Convert.ToByte(Strings.Mid(sFeedBackFromSlave, iPositionOfFunctionCodeInReceivedString, 2));//功能码

            //    //数据字符串
            //    int iLength = sFeedBackFromSlave.Length;
            //    int iCopyDataLength = iLength - iStartPositonOfFeedbackData - 2;
            //    gotData.DataString = Strings.Mid(sFeedBackFromSlave, iStartPositonOfFeedbackData, iCopyDataLength);
            //}
            //catch (Exception ex)
            //{
            //    gotData.ErrorMsg = ex.Message + "; " + ex.StackTrace;
            //}

            //qReceivedDataQueue.Enqueue(gotData);

            #endregion
        }

        /// <summary>
        /// 将Modbus-Ascii接收到的字节信息进行解析
        /// </summary>
        /// <param name="ReceivedMsg">接收到的字节信息</param>
        /// <returns></returns>
        private CReadbackData UnpackReceivedAsciiMsg(byte[] ReceivedMsg)
        {
            //原始字符串、原始字节数组、从站地址、功能码、数据字符串/字节数组、日期和时间、是否CRC校验OK、是否LRC校验OK

            CReadbackData gotData = new CReadbackData();
            gotData.ReceivedDateTime = DateTime.Now;//UtcNow  日期和时间

            try
            {
                gotData.ReceivedBytes = ReceivedMsg;//原始字节数组

                //将字节数组转化为16进制字符串
                string sFeedBackFromSlave = CConverter.Bytes1To2HexStr(ReceivedMsg);
                gotData.ReceivedString = sFeedBackFromSlave;//原始字符串

                if (bSaveReceivedStringToLog == true)
                {
                    if (string.IsNullOrEmpty(sFeedBackFromSlave) == false)
                    {
                        Enqueue("收到字节转换为16进制 - " + sFeedBackFromSlave);
                    }
                }

                //计算LRC  是否LRC校验OK
                if (CalcLRCForReceivedStringFromSlave(sFeedBackFromSlave) == false)
                {
                    gotData.IsLRCOK = false;
                    if (bSaveReceivedStringToLog == true)
                    {
                        Enqueue("错误 - 收到字节进行CRC校验时，收到的CRC码和计算的CRC码不匹配");
                    }
                }
                else
                {
                    gotData.IsLRCOK = true;
                }

                //首字符
                //[0] - :

                //从站地址
                //[1] - 0
                //[2] - 1

                //读取成功的功能码
                //[3] - 0
                //[4] - 1

                //读取失败的错误码
                //[3] - 0
                //[4] - 8

                gotData.SlaveAddress = Convert.ToByte(Strings.Mid(sFeedBackFromSlave, PosOfSlaveAddressInAsciiReceivedString, 2));//从站地址

                gotData.FuncCode = Convert.ToByte(Strings.Mid(sFeedBackFromSlave, PosOfFuncCodeInAsciiReceivedString, 2));//功能码
                gotData.FuncDescription = CModbusFuncCode.FuncInfo((ModbusFuncCode)gotData.FuncCode);//功能码的描述信息

                gotData.ErrorCode = Convert.ToByte(Strings.Mid(sFeedBackFromSlave, PosOfErrorCodeInAsciiReceivedString  , 2));//错误码
                gotData.ErrorMsg = AnalysisErrorCode(ReceivedMsg);//错误码的描述信息

                //数据字符串
                int iLength = sFeedBackFromSlave.Length;
                int iCopyDataLength = iLength - StartPosOfDataInAsciiReceivedString - 4;//LRC占2个字节，共4个字符
                if (iCopyDataLength > 0)
                {
                    gotData.DataString = Strings.Mid(sFeedBackFromSlave, StartPosOfDataInAsciiReceivedString, iCopyDataLength);
                }
            }
            catch (Exception ex)
            {
                gotData.ErrorMsg = ex.Message + "; " + ex.StackTrace;
            }

            return gotData;
        }

        /// <summary>
        /// 执行读写时的错误信息
        /// </summary>
        string sErrorMsgForReadWrite = "";

        /// <summary>
        /// 发送数据到串口并接收串口返回的数据
        /// </summary>
        /// <param name="byResult">要发送的字节数据</param>
        /// <param name="DeviceAddress">目标从站地址</param>
        /// <returns></returns>
        private string WriteAndReadBytes(byte[] byResult, byte DeviceAddress)
        {
            //, string sCmdDataToBeSent         <param name="sCmdDataToBeSent">要发送的数据字符串，用于保存至日志</param> 
            string sReadData = "";

            try
            {
                Lock();

                //清除发送前的接收缓冲区
                ClearReceiveBuffer();

                // 通过串口发送指令数据给客户端
                RS232CPort.Write(byResult, 0, byResult.Length);

                bIsConnected = true;

                if (bSaveSendStringToLog == true)
                {
                    string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
                    Enqueue("发送字符串 - " + sCmdDataToBeSent);
                }

                // 读取客户端的返回信息
                Stopwatch swUsedTime = new Stopwatch();
                swUsedTime.Restart();

                while (RS232CPort.BytesToRead < iMinLengthOfResponse)
                {
                    if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
                    {
                        Unlock();
                        throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
                        //break;
                    }

                    //Application.DoEvents();
                    System.Threading.Thread.Sleep(iSleepTime);
                }

                sReadData = RS232CPort.ReadExisting();
            }
            catch (Exception ex)
            {
                bIsConnected = RS232CPort.IsOpen;

                if (sErrorMsgForReadWrite != ex.Message)
                {
                    sErrorMsgForReadWrite = ex.Message;
                    Enqueue("通讯时发生错误：" + ex.Message + "  " + ex.StackTrace);
                }
            }

            Unlock();

            return sReadData;
        }

        /// <summary>
        /// TBD -- 解析返回信息的错误代码
        /// </summary>
        /// <param name="MsgWithErrorCode">从站返回的完整字符串(含错误信息)</param>
        /// <returns></returns>
        public string AnalysisErrorCode(string MsgWithErrorCode)
        {
            if (MsgWithErrorCode.IndexOf(':') != -1)
            {
                string sTemp = Strings.Mid(MsgWithErrorCode, 2, MsgWithErrorCode.Length - 1);//去掉第一个字符 ':'
                MsgWithErrorCode = sTemp;
            }

            int iPos = MsgWithErrorCode.IndexOf(RS232CPort.NewLine);
            if (iPos != -1)
            {
                string sTemp = Strings.Mid(MsgWithErrorCode, 1, iPos);//去掉第一个字符 ':'
                MsgWithErrorCode = sTemp;
            }
            
            return AnalysisErrorCode(CConverter.Hex2StrTo1Byte(MsgWithErrorCode));//将去掉首字符 ':' 和结束符的字符串按照 2个字符1个字节的方式转化为字节数组
        }

        /// <summary>
        /// 解析返回信息的错误代码，此字节数组必须是去掉首字符 ':' 和结束符的字符串按照 2个字符1个字节的方式转化为字节数组
        /// </summary>
        /// <param name="MsgWithErrorCode">从站返回的完整字节数组(含错误信息)</param>
        /// <returns></returns>
        public string AnalysisErrorCode(byte[] MsgWithErrorCode)
        {
            CReadbackData Msg = CModbusErrorCode.AnalysisErrorCode(MsgWithErrorCode, ModbusCommType.Ascii);
            if (null == Msg)
            {
                return "";
            }
            else
            {
                //string sTemp = "从站[" + Msg.SlaveAddress.ToString() + "], 功能码[" + Msg.FuncCode.ToString() + "](" + Msg.FuncDescription + "), 错误码[" + Msg.ErrorCode.ToString() + "], 错误信息[" + Msg.ErrorMsg + "]";

                Enqueue(Msg.ErrorMsg);

                return Msg.ErrorMsg;
            }
        }

        /// <summary>
        /// 创建读取命令的字节数组，可以直接发送这个字节数组到串口端口
        /// </summary>
        /// <param name="DeviceAddress">从站地址</param>
        /// <param name="ReadFunctionCode">读取功能码</param>
        /// <param name="BeginReadAddress">读取的起始地址</param>
        /// <param name="ReadDataLength">读取数据长度，有效值范围：1~2000(位)</param>
        /// <returns></returns>
        private static byte[] PackReadCmd(byte DeviceAddress, ModbusFuncCode ReadFunctionCode, ushort BeginReadAddress, ushort ReadDataLength)
        {
            return Converter.Modbus.ModbusAscii.PackReadCmd(DeviceAddress, ReadFunctionCode, BeginReadAddress, ReadDataLength);

            ////byte[] byResultData = null;// new byte[15];

            //try
            //{
            //    if (ReadDataLength < 1 || ReadDataLength > 2000)//读取数据长度，有效值范围：1~2000(位)
            //    {
            //        throw new Exception("读取数据长度的值不正确，有效值范围：1~2000(位)，换算为1~250个字节");
            //    }

            //    string sReadCmd = DeviceAddress.ToString("X2");//设备地址码，1个字节，2个字符
            //    sReadCmd += ((byte)ReadFunctionCode).ToString("X2");//功能码，1个字节，2个字符
            //    sReadCmd += BeginReadAddress.ToString("X4");//起始地址，2个字节，4个字符
            //    sReadCmd += ReadDataLength.ToString("X4");//读取数据长度，2个字节，4个字符

            //    return CalcResultsIncludeLRC(sReadCmd);
            //}
            //catch (Exception)
            //{
            //    return null;
            //}

            ////return byResultData;
        }

        /// <summary>
        /// 封装写单个线圈/保持寄存器命令，返回处理好的字节数组
        /// </summary>
        /// <param name="DeviceAddress">从站地址</param>
        /// <param name="FuncCode">功能码</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="Data">要发送的数据的字节数组</param>
        /// <returns></returns>
        private byte[] PackSingleWriteCmd(byte DeviceAddress, ModbusFuncCode FuncCode, ushort BeginAddress, string Data)
        {
            return Converter.Modbus.ModbusAscii.PackSingleWriteCmd(DeviceAddress, FuncCode, BeginAddress, Data, ParaBytesFormat);

            //if (null == Data || Data.Length < 1)
            //{
            //    return null;
            //}

            //if (FuncCode != ModbusFuncCode.WriteCoil && FuncCode != ModbusFuncCode.WriteRegister)
            //{
            //    return null;
            //}

            ////地址码    功能码    设置起始地址   设置值      CRC
            ////1字节     1字节     2字节          2字节      2字节
            //// 求 LRC -- 设备地址(2个字符) + 功能码(2个字符) + 起始地址(4个字符) + 数据值(4个字符)

            //string sCmdToCalcLRC = "";
            //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)

            //sCmdToCalcLRC += ((byte)FuncCode).ToString("X2");//功能码(2个字符)

            //byte[] byTemp = CConverter.ToBytes((short)BeginAddress, ParaBytesFormat);
            //string sBytesToHexStr = CConverter.Bytes2To4HexStr(byTemp);
            //sCmdToCalcLRC += CConverter.Bytes2To4HexStr(CConverter.ToBytes((short)BeginAddress, ParaBytesFormat));//起始地址(4个字符)

            //// 设置值
            //sCmdToCalcLRC += Data;

            //return CalcResultsIncludeLRC(sCmdToCalcLRC);

            #region "Old codes -- No use"

            //string sCmdToCalcLRC = "";
            //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
            //sCmdToCalcLRC += CModbusFuncCode.WriteRegister.ToString("X2");//功能码(2个字符)

            //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
            //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
            //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

            ////设置值
            //sCmdToCalcLRC += SetValue.ToString("X4");

            //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

            //sCmdToCalcLRC = null;

            ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

            #endregion

            #region "Old codes -- For reference"

            //string sCmdToCalcLRC = "";
            //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
            //sCmdToCalcLRC += CModbusFuncCode.WriteCoil.ToString("X2");//功能码(2个字符)

            //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
            //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
            //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

            //// 单个线圈值的设置
            ////0x0000	释放继电器线圈
            ////0xFF00	吸合继电器线圈
            //if (IsOn == true)
            //{
            //    sCmdToCalcLRC += "FF00";
            //}
            //else
            //{
            //    sCmdToCalcLRC += "0000";
            //}
            ////byte[] byDataLength = IntToHex(1);//数据长度(4个字符)
            ////sCmdToCalcLRC += byDataLength[0].ToString("X2");
            ////sCmdToCalcLRC += byDataLength[1].ToString("X2");

            //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

            //sCmdToCalcLRC = null;

            //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

            #endregion
        }

        /// <summary>
        /// 封装写多个线圈/保持寄存器命令，返回处理好的字节数组
        /// </summary>
        /// <param name="DeviceAddress">从站地址</param>
        /// <param name="FuncCode">功能码</param>
        /// <param name="BeginAddress">起始地址</param>
        /// <param name="DataLength">要发送的数据的数量：线圈 -- 位(bool)；寄存器 -- 字(short)</param>
        /// <param name="BytesCount">要发送数据的字节数</param>
        /// <param name="Data">要发送的数据的字节数组</param>
        /// <returns></returns>
        private byte[] PackMultiWriteCmd(byte DeviceAddress, ModbusFuncCode FuncCode, ushort BeginAddress, int DataLength, int BytesCount, string Data)
        {
            return Converter.Modbus.ModbusAscii.PackMultiWriteCmd(DeviceAddress, FuncCode, BeginAddress, DataLength, BytesCount, Data, ParaBytesFormat);

            //if (null == Data || Data.Length < 1)
            //{
            //    return null;
            //}

            //if (FuncCode != ModbusFuncCode.WriteMultiCoil && FuncCode != ModbusFuncCode.WriteMultiRegister)
            //{
            //    return null;
            //}

            //int iDataByteLength = Data.Length;

            ////:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
            ////1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
            ////1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

            //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
            //string sCmdToCalcLRC = "";

            ////设备地址 - 1个字节， 2个字符
            //sCmdToCalcLRC += CConverter.Byte1To2HexStr(DeviceAddress);

            ////功能码 - 1个字节， 2个字符
            //sCmdToCalcLRC += CConverter.Byte1To2HexStr((byte)FuncCode);

            ////起始地址 - 2个字节， 4个字符
            //sCmdToCalcLRC += CConverter.Bytes2To4HexStr(CConverter.ToBytes((short)BeginAddress, ParaBytesFormat));

            ////数据长度 - 2个字节， 4个字符
            ////byte[] byDataLength = CConverter.ToBytes(DataLength, ParaBytesFormat);
            //sCmdToCalcLRC += CConverter.Bytes2To4HexStr(CConverter.ToBytes((short)DataLength, ParaBytesFormat));

            //// 字节计数 - 1个字节， 2个字符
            //sCmdToCalcLRC += Convert.ToByte(BytesCount).ToString("X2");
            ////byte[] byBytesCount = BitConverter.GetBytes(BytesCount);
            ////sCmdToCalcLRC += CConverter.Byte1To2HexStr(byBytesCount[0]);
            ////sCmdToCalcLRC += CConverter.Byte1To2HexStr((byte)BytesCount);

            //// 设置值 - 4*N个字符
            //sCmdToCalcLRC += Data;

            //return CalcResultsIncludeLRC(sCmdToCalcLRC);

            #region "Old codes -- No use"

            //string sCmdToCalcLRC = "";
            //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
            //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

            //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
            //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
            //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

            ////数据字长度 - 字数据的长度
            //int iDataLength = 2;
            //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
            //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
            //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

            //// 字节计数
            //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
            //sCmdToCalcLRC += byByteCount.ToString("X2");

            ////设置值
            //byte[] byFloatToBytes = BitConverter.GetBytes(SetValue);
            //for (int i = 0; i < byFloatToBytes.Length / 2; i++)
            //{
            //    sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
            //    sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
            //}

            //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

            //sCmdToCalcLRC = null;

            ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

            #endregion

            #region "Old code for reference"

            //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
            //string sCmdToCalcLRC = "";
            //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
            //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

            //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
            //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
            //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

            ////数据位长度 - 位的数据长度
            //int iDataLength = SetValue.Length;
            //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
            //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
            //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

            //// 字节计数
            //byte byByteCount = Convert.ToByte(iDataLength / 8);//bool[]数组长度 / 8 = 字节数
            //sCmdToCalcLRC += byByteCount.ToString("X2");

            //// 线圈值的设置 - 将布尔数组转换为字节数组
            //byte[] byBitArrayToBytes = CConverter.BitArrayToByte(SetValue);
            //for (int i = 0; i < byBitArrayToBytes.Length; i++)
            //{
            //    sCmdToCalcLRC += byBitArrayToBytes[i].ToString("X2");
            //}

            ////byte[] byDataLength = IntToHex(1);//数据长度(4个字符)
            ////sCmdToCalcLRC += byDataLength[0].ToString("X2");
            ////sCmdToCalcLRC += byDataLength[1].ToString("X2");

            //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

            //sCmdToCalcLRC = null;

            #endregion
        }

        /// <summary>
        /// 将命令字符串转化为字节，然后计算LRC，并返回计算后的总字节数组
        /// </summary>
        /// <param name="CmdData"></param>
        /// <returns></returns>
        static byte[] CalcResultsIncludeLRC(string CmdData)
        {
            return Converter.Modbus.ModbusAscii.CalcResultsIncludeLRC(CmdData);
        }

        #region "New Methods"

        ///// <summary>
        ///// 封装写多个线圈/保持寄存器命令，返回处理好的字节数组
        ///// </summary>
        ///// <param name="DeviceAddress">从站地址</param>
        ///// <param name="FuncCode">功能码</param>
        ///// <param name="BeginAddress">起始地址</param>
        ///// <param name="DataLength">要发送的数据的数量：线圈 -- 位(bool)；寄存器 -- 字(short)</param>
        ///// <param name="BytesCount">要发送数据的字节数</param>
        ///// <param name="Data">要发送的数据的字节数组</param>
        ///// <returns></returns>
        //private static byte[] PackMultiWriteCmd(byte DeviceAddress, ModbusFuncCode FuncCode, ushort BeginAddress, int DataLength, int BytesCount, string Data, BytesFormat ParaBytesFormat)
        //{
        //    if (null == Data || Data.Length < 1)
        //    {
        //        return null;
        //    }

        //    if (FuncCode != ModbusFuncCode.WriteMultiCoil && FuncCode != ModbusFuncCode.WriteMultiRegister)
        //    {
        //        return null;
        //    }

        //    int iDataByteLength = Data.Length;

        //    //:         地址码         功能码    设置起始地址   设置长度   字节计数   设置内容      LRC      回车+换行符
        //    //1字符     2字符          2字符     4字符          4字符      2字符      2*N字符      1字符    2字符
        //    //1字节     1字节          1字节     2字节          2字节      1字节      N字节        1字节    2字节

        //    // 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
        //    string sCmdToCalcLRC = "";

        //    //设备地址 - 1个字节， 2个字符
        //    sCmdToCalcLRC += CConverter.Byte1To2HexStr(DeviceAddress);

        //    //功能码 - 1个字节， 2个字符
        //    sCmdToCalcLRC += CConverter.Byte1To2HexStr((byte)FuncCode);

        //    //起始地址 - 2个字节， 4个字符
        //    sCmdToCalcLRC += CConverter.Bytes2To4HexStr(CConverter.ToBytes((short)BeginAddress, ParaBytesFormat));

        //    //数据长度 - 2个字节， 4个字符
        //    //byte[] byDataLength = CConverter.ToBytes(DataLength, ParaBytesFormat);
        //    sCmdToCalcLRC += CConverter.Bytes2To4HexStr(CConverter.ToBytes((short)DataLength, ParaBytesFormat));

        //    // 字节计数 - 1个字节， 2个字符
        //    sCmdToCalcLRC += Convert.ToByte(BytesCount).ToString("X2");
        //    //byte[] byBytesCount = BitConverter.GetBytes(BytesCount);
        //    //sCmdToCalcLRC += CConverter.Byte1To2HexStr(byBytesCount[0]);
        //    //sCmdToCalcLRC += CConverter.Byte1To2HexStr((byte)BytesCount);

        //    // 设置值 - 4*N个字符
        //    sCmdToCalcLRC += Data;

        //    return CalcResultsIncludeLRC(sCmdToCalcLRC);

        //    #region "Old codes -- No use"

        //    //string sCmdToCalcLRC = "";
        //    //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
        //    //sCmdToCalcLRC += CModbusFuncCode.WriteMultiRegister.ToString("X2");//功能码(2个字符)

        //    //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
        //    //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
        //    //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

        //    ////数据字长度 - 字数据的长度
        //    //int iDataLength = 2;
        //    //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
        //    //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
        //    //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

        //    //// 字节计数
        //    //byte byByteCount = Convert.ToByte(iDataLength * 2);//字长度 * 2 = 字节数
        //    //sCmdToCalcLRC += byByteCount.ToString("X2");

        //    ////设置值
        //    //byte[] byFloatToBytes = BitConverter.GetBytes(SetValue);
        //    //for (int i = 0; i < byFloatToBytes.Length / 2; i++)
        //    //{
        //    //    sCmdToCalcLRC += byFloatToBytes[i * 2 + 1].ToString("X2");// 数据 - 高字节
        //    //    sCmdToCalcLRC += byFloatToBytes[i * 2].ToString("X2");// 数据 - 低字节                    
        //    //}

        //    //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

        //    //sCmdToCalcLRC = null;

        //    ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

        //    #endregion

        //    #region "Old code for reference"

        //    //// 求 LRC -- 设备地址(1字节)   功能码(1字节)    设置起始地址(2字节)   数据位长度(2字节)   字节计数(1字节)   设置内容(N字节)
        //    //string sCmdToCalcLRC = "";
        //    //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
        //    //sCmdToCalcLRC += CModbusFuncCode.WriteMultiCoil.ToString("X2");//功能码(2个字符)

        //    //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
        //    //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
        //    //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

        //    ////数据位长度 - 位的数据长度
        //    //int iDataLength = SetValue.Length;
        //    //byte[] byDataLength = CConverter.ToBytes(iDataLength, ParaBytesFormat);
        //    //sCmdToCalcLRC += byDataLength[1].ToString("X2");// 数据长度 - 高字节
        //    //sCmdToCalcLRC += byDataLength[0].ToString("X2");// 数据长度 - 低字节

        //    //// 字节计数
        //    //byte byByteCount = Convert.ToByte(iDataLength / 8);//bool[]数组长度 / 8 = 字节数
        //    //sCmdToCalcLRC += byByteCount.ToString("X2");

        //    //// 线圈值的设置 - 将布尔数组转换为字节数组
        //    //byte[] byBitArrayToBytes = CConverter.BitArrayToByte(SetValue);
        //    //for (int i = 0; i < byBitArrayToBytes.Length; i++)
        //    //{
        //    //    sCmdToCalcLRC += byBitArrayToBytes[i].ToString("X2");
        //    //}

        //    ////byte[] byDataLength = IntToHex(1);//数据长度(4个字符)
        //    ////sCmdToCalcLRC += byDataLength[0].ToString("X2");
        //    ////sCmdToCalcLRC += byDataLength[1].ToString("X2");

        //    //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

        //    //sCmdToCalcLRC = null;

        //    #endregion
        //}

        ///// <summary>
        ///// 封装写单个线圈/保持寄存器命令，返回处理好的字节数组
        ///// </summary>
        ///// <param name="DeviceAddress">从站地址</param>
        ///// <param name="FuncCode">功能码</param>
        ///// <param name="BeginAddress">起始地址</param>
        ///// <param name="Data">要发送的数据的字节数组</param>
        ///// <returns></returns>
        //private static byte[] PackSingleWriteCmd(byte DeviceAddress, ModbusFuncCode FuncCode, ushort BeginAddress, string Data, BytesFormat ParaBytesFormat)
        //{
        //    if (null == Data || Data.Length < 1)
        //    {
        //        return null;
        //    }

        //    if (FuncCode != ModbusFuncCode.WriteCoil && FuncCode != ModbusFuncCode.WriteRegister)
        //    {
        //        return null;
        //    }

        //    //地址码    功能码    设置起始地址   设置值      CRC
        //    //1字节     1字节     2字节          2字节      2字节
        //    // 求 LRC -- 设备地址(2个字符) + 功能码(2个字符) + 起始地址(4个字符) + 数据值(4个字符)

        //    string sCmdToCalcLRC = "";
        //    sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)

        //    sCmdToCalcLRC += ((byte)FuncCode).ToString("X2");//功能码(2个字符)

        //    byte[] byTemp = CConverter.ToBytes((short)BeginAddress, ParaBytesFormat);
        //    string sBytesToHexStr = CConverter.Bytes2To4HexStr(byTemp);
        //    sCmdToCalcLRC += CConverter.Bytes2To4HexStr(CConverter.ToBytes((short)BeginAddress, ParaBytesFormat));//起始地址(4个字符)

        //    // 设置值
        //    sCmdToCalcLRC += Data;

        //    return CalcResultsIncludeLRC(sCmdToCalcLRC);

        //    #region "Old codes -- No use"

        //    //string sCmdToCalcLRC = "";
        //    //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
        //    //sCmdToCalcLRC += CModbusFuncCode.WriteRegister.ToString("X2");//功能码(2个字符)

        //    //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
        //    //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
        //    //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

        //    ////设置值
        //    //sCmdToCalcLRC += SetValue.ToString("X4");

        //    //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

        //    //sCmdToCalcLRC = null;

        //    ////string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

        //    #endregion

        //    #region "Old codes -- For reference"

        //    //string sCmdToCalcLRC = "";
        //    //sCmdToCalcLRC += DeviceAddress.ToString("X2");//设备地址(2个字符)
        //    //sCmdToCalcLRC += CModbusFuncCode.WriteCoil.ToString("X2");//功能码(2个字符)

        //    //byte[] byBeginAddress = CConverter.ToBytes(BeginAddress, ParaBytesFormat);//起始地址(4个字符)
        //    //sCmdToCalcLRC += byBeginAddress[1].ToString("X2");// 起始地址 - 高字节
        //    //sCmdToCalcLRC += byBeginAddress[0].ToString("X2");// 起始地址 - 低字节

        //    //// 单个线圈值的设置
        //    ////0x0000	释放继电器线圈
        //    ////0xFF00	吸合继电器线圈
        //    //if (IsOn == true)
        //    //{
        //    //    sCmdToCalcLRC += "FF00";
        //    //}
        //    //else
        //    //{
        //    //    sCmdToCalcLRC += "0000";
        //    //}
        //    ////byte[] byDataLength = IntToHex(1);//数据长度(4个字符)
        //    ////sCmdToCalcLRC += byDataLength[0].ToString("X2");
        //    ////sCmdToCalcLRC += byDataLength[1].ToString("X2");

        //    //byte[] byResult = HexCmdConvertToBytesIncludeLRC(sCmdToCalcLRC);

        //    //sCmdToCalcLRC = null;

        //    //string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);

        //    #endregion
        //}

        ///// <summary>
        ///// 创建读取命令的字节数组，可以直接发送这个字节数组到串口端口
        ///// </summary>
        ///// <param name="DeviceAddress">从站地址</param>
        ///// <param name="ReadFunctionCode">读取功能码</param>
        ///// <param name="BeginReadAddress">读取的起始地址</param>
        ///// <param name="ReadDataLength">读取数据长度，有效值范围：1~2000(位)</param>
        ///// <returns></returns>
        //private static byte[] MakeReadCmd(byte DeviceAddress, ModbusFuncCode ReadFunctionCode, ushort BeginReadAddress, ushort ReadDataLength)
        //{
        //    //byte[] byResultData = null;// new byte[15];

        //    try
        //    {
        //        if (ReadDataLength < 1 || ReadDataLength > 2000)//读取数据长度，有效值范围：1~2000(位)
        //        {
        //            throw new Exception("读取数据长度的值不正确，有效值范围：1~2000(位)，换算为1~250个字节");
        //        }

        //        string sReadCmd = DeviceAddress.ToString("X2");//设备地址码，1个字节，2个字符
        //        sReadCmd += ((byte)ReadFunctionCode).ToString("X2");//功能码，1个字节，2个字符
        //        sReadCmd += BeginReadAddress.ToString("X4");//起始地址，2个字节，4个字符
        //        sReadCmd += ReadDataLength.ToString("X4");//读取数据长度，2个字节，4个字符

        //        return CalcResultsIncludeLRC(sReadCmd);
        //    }
        //    catch (Exception)
        //    {
        //        return null;
        //    }

        //    //return byResultData;
        //}

        ///// <summary>
        ///// 将命令字符串转化为字节，然后计算LRC，并返回计算后的总字节数组
        ///// </summary>
        ///// <param name="CmdData"></param>
        ///// <returns></returns>
        //static byte[] CalcResultsIncludeLRC(string CmdData)
        //{
        //    byte[] byResults = null;

        //    try
        //    {

        //        byte[] byCommandStringToBytes = Encoding.ASCII.GetBytes(CmdData);

        //        byte[] byLRCResult = CalcLRCBytes(CmdData);
        //        if (null == byLRCResult || byLRCResult.Length != 2)
        //        {
        //            throw new Exception("LRC计算错误");
        //        }

        //        byResults = new byte[byCommandStringToBytes.Length + 5];

        //        byResults[0] = 0x3A;

        //        //ASCII字符转换为字节，共 6 个字节
        //        for (int i = 0; i < byCommandStringToBytes.Length; i++)
        //        {
        //            byResults[i + 1] = byCommandStringToBytes[i];
        //        }

        //        //LRC
        //        byResults[byCommandStringToBytes.Length + 1 + 0] = byLRCResult[0];
        //        byResults[byCommandStringToBytes.Length + 1 + 1] = byLRCResult[1];

        //        //CRLF
        //        byResults[byCommandStringToBytes.Length + 1 + 2] = 0x0D;
        //        byResults[byCommandStringToBytes.Length + 1 + 3] = 0x0A;
        //    }
        //    catch (Exception)// ex)
        //    {
        //        //Enqueue(ex.Message + "  " + ex.StackTrace);
        //    }

        //    return byResults;
        //}

        #endregion

        #region "No use"



        ///// <summary>
        ///// 发送数据到串口并接收串口返回的数据
        ///// </summary>
        ///// <param name="byResult">要发送的字节数据</param>
        ///// <param name="DeviceAddress">目标从站地址</param>
        ///// <returns></returns>
        //private byte[] WriteAndReadBytes(byte[] byResult, byte DeviceAddress)
        //{
        //    //, string sCmdDataToBeSent         <param name="sCmdDataToBeSent">要发送的数据字符串，用于保存至日志</param> 
        //    byte[] byReadData = null;

        //    try
        //    {
        //        Lock();

        //        //清除发送前的接收缓冲区
        //        ClearReceiveBuffer();

        //        // 通过串口发送指令数据给客户端
        //        RS232CPort.Write(byResult, 0, byResult.Length);

        //        if (bSaveSendStringToLog == true)
        //        {
        //            string sCmdDataToBeSent = Encoding.ASCII.GetString(byResult);
        //            Enqueue("发送字符串 - " + sCmdDataToBeSent);
        //        }

        //        // 读取客户端的返回信息
        //        Stopwatch swUsedTime = new Stopwatch();
        //        swUsedTime.Restart();

        //        while (RS232CPort.BytesToRead < iMinLengthOfResponse)
        //        {
        //            if (swUsedTime.ElapsedMilliseconds >= iWaitFeedbackTime)
        //            {
        //                Unlock();
        //                throw new Exception("超时未收到从站 [" + DeviceAddress.ToString("") + "] 的反馈信息");
        //                //break;
        //            }

        //            //Application.DoEvents();
        //            System.Threading.Thread.Sleep(iSleepTime);
        //        }

        //        byReadData = Encoding.UTF8.GetBytes(RS232CPort.ReadExisting());
        //    }
        //    catch (Exception ex)
        //    {
        //        Enqueue("通讯时发生错误：" + ex.Message + "  " + ex.StackTrace);
        //    }

        //    Unlock();

        //    return byReadData;
        //}

        ///// <summary>
        ///// 【此字节数组可直接通过串口发送】
        ///// 将 16 进制 Modbus Ascii 命令字符串转换为字节数组，命令字符串不要包含 ':' 和 '回车+换行'，程序会自动添加；
        ///// 格式：地址(2个字符) + 功能码(2个字符) + 起始地址(4个字符) + 数据长度(4个字符)
        ///// </summary>
        ///// <param name="ModbusAsciiHexCommand">16进制字符串</param>
        ///// <returns></returns>
        //public static byte[] HexCmdConvertToBytesIncludeLRC(string ModbusAsciiHexCommand)
        //{
        //    byte[] byResults = null;

        //    try
        //    {
        //        if (string.IsNullOrEmpty(ModbusAsciiHexCommand) == true)
        //        {
        //            throw new Exception("Modbus Ascii 命令字符串不能为空");
        //        }

        //        if (ModbusAsciiHexCommand[0] == ':')
        //        {
        //            ModbusAsciiHexCommand = ModbusAsciiHexCommand.Remove(0, 1);
        //        }

        //        if (Strings.Left(ModbusAsciiHexCommand, 2) == "\r\n")
        //        {
        //            ModbusAsciiHexCommand = ModbusAsciiHexCommand.Remove(ModbusAsciiHexCommand.Length - 2, 2);
        //        }

        //        if (ModbusAsciiHexCommand.Length % 2 != 0)
        //        {
        //            throw new Exception("Modbus Ascii 命令字符串长度不正确，应该是2的整数倍");
        //        }

        //        // 执行写的时候，命令字符串的长度不是固定的
        //        //if (ModbusAsciiCommand.Length != 10)
        //        //{
        //        //    throw new Exception("Modbus Ascii 命令字符串长度不正确，应该是10个字符");
        //        //}

        //        byte[] byCommandStringToBytes = Encoding.ASCII.GetBytes(ModbusAsciiHexCommand);


        //        byte[] byLRCResult = CalcLRCBytes(ModbusAsciiHexCommand);
        //        if (null == byLRCResult || byLRCResult.Length != 2)
        //        {
        //            throw new Exception("LRC计算错误");
        //        }

        //        byResults = new byte[byCommandStringToBytes.Length + 3];// + 5

        //        byResults[0] = 0x3A;

        //        //ASCII字符转换为字节，共 6 个字节
        //        for (int i = 0; i < byCommandStringToBytes.Length; i++)
        //        {
        //            byResults[i + 1] = byCommandStringToBytes[i];
        //        }

        //        //LRC
        //        byResults[byCommandStringToBytes.Length + 1 + 0] = byLRCResult[0];
        //        byResults[byCommandStringToBytes.Length + 1 + 1] = byLRCResult[1];

        //        ////CRLF
        //        //byResults[byCommandStringToBytes.Length + 1 + 2] = 0x0D;
        //        //byResults[byCommandStringToBytes.Length + 1 + 3] = 0x0A;
        //    }
        //    catch (Exception)// ex)
        //    {
        //        //Enqueue(ex.Message + "  " + ex.StackTrace);
        //    }

        //    return byResults;
        //}

        #endregion

        /// <summary>
        /// 计算LRC值，返回长度为2的字节数组 -- 格式：地址(2个字符) + 功能码(2个字符) + 起始地址(4个字符) + 数据长度(4个字符)
        /// </summary>
        /// <param name="ModbusAsciiCommand">16进制字符串</param>
        /// <returns></returns>
        public static byte[] CalcLRCBytes(string ModbusAsciiCommand)
        {
            return Converter.Modbus.CLRC.CalcLRCBytes(ModbusAsciiCommand);

            #region "Old codes - no use"

            //byte[] byLRCResult = null;

            //try
            //{
            //    if (string.IsNullOrEmpty(ModbusAsciiCommand) == true)
            //    {
            //        throw new Exception("Modbus Ascii 命令字符串不能为空");
            //    }

            //    if (ModbusAsciiCommand[0] == ':')
            //    {
            //        ModbusAsciiCommand = ModbusAsciiCommand.Remove(0, 1);
            //    }

            //    if (Strings.Left(ModbusAsciiCommand, 2) == "\r\n")
            //    {
            //        ModbusAsciiCommand = ModbusAsciiCommand.Remove(ModbusAsciiCommand.Length - 2, 2);
            //    }

            //    if (Strings.Left(ModbusAsciiCommand, 1) == "\r" || Strings.Left(ModbusAsciiCommand, 1) == "\n")
            //    {
            //        ModbusAsciiCommand = ModbusAsciiCommand.Remove(ModbusAsciiCommand.Length - 1, 1);

            //        //
            //        if (Strings.Left(ModbusAsciiCommand, 1) == "\r" || Strings.Left(ModbusAsciiCommand, 1) == "\n")
            //        {
            //            ModbusAsciiCommand = ModbusAsciiCommand.Remove(ModbusAsciiCommand.Length - 1, 1);
            //        }
            //    }
            //    else
            //    {
            //        //如果倒数第二个字符是回车或换行符号就将其删除，并将最后一个字符前移一个位置
            //        if (Strings.Mid(ModbusAsciiCommand, ModbusAsciiCommand.Length - 2, 1) == "\r" || Strings.Mid(ModbusAsciiCommand, ModbusAsciiCommand.Length - 2, 1) == "\n")
            //        {
            //            string sTemp = Strings.Mid(ModbusAsciiCommand, 1, ModbusAsciiCommand.Length - 2);
            //            sTemp += ModbusAsciiCommand[ModbusAsciiCommand.Length];
            //            ModbusAsciiCommand = sTemp;
            //        }
            //    }

            //    if (ModbusAsciiCommand.Length % 2 != 0)
            //    {
            //        throw new Exception("Modbus Ascii 命令字符串长度不正确，应该是2的整数倍");
            //    }

            //    // 执行写的时候，命令字符串的长度不是固定的
            //    //if (ModbusAsciiCommand.Length != 10)
            //    //{
            //    //    throw new Exception("Modbus Ascii 命令字符串长度不正确，应该是10个字符");
            //    //}

            //    byte[] byBytesToCalcLRC = new byte[ModbusAsciiCommand.Length / 2];

            //    for (int i = 0; i < ModbusAsciiCommand.Length / 2; i++)
            //    {
            //        string sTemp = Strings.Mid(ModbusAsciiCommand, i * 2 + 1, 2);
            //        byBytesToCalcLRC[i] = CConverter.TwoHexCharsToByte(sTemp);
            //    }

            //    // 计算字节求和值
            //    int iAdditionValue = 0;
            //    byte bySumValue = 0;
            //    for (int i = 0; i < byBytesToCalcLRC.Length; i++)//
            //    {
            //        iAdditionValue += byBytesToCalcLRC[i];//
            //    }

            //    // 取字节累加值的第1个字节， int 包含 4 个字节
            //    byte[] byLatestTemp = BitConverter.GetBytes(iAdditionValue);
            //    bySumValue = byLatestTemp[0];

            //    // 取反
            //    bySumValue = Convert.ToByte(255 ^ bySumValue);
            //    //bySumValue = (byte)(255 - bySumValue);

            //    // +1
            //    bySumValue += 1;

            //    byLRCResult = new byte[2];
            //    string sLRCResult = bySumValue.ToString("X2");
            //    for (int i = 0; i < byLRCResult.Length; i++)
            //    {
            //        byLRCResult[i] = Convert.ToByte(sLRCResult[i]);
            //    }
            //}
            //catch (Exception)// ex)
            //{
            //    //Enqueue(ex.Message + "  " + ex.StackTrace);
            //}

            //return byLRCResult;

            #endregion
        }

        /// <summary>
        /// 计算LRC值，返回长度为2的字节数组 -- 格式：地址(2个字符) + 功能码(2个字符) + 起始地址(4个字符) + 数据长度(4个字符)
        /// </summary>
        /// <param name="DataUsedToCalcLRC">用于计算LRC的字节数组</param>
        /// <returns></returns>
        public static byte[] CalcLRCBytes(byte[] DataUsedToCalcLRC)
        {
            return Converter.Modbus.CLRC.CalcLRCBytes(DataUsedToCalcLRC);

            #region "Old codes - no use"

            //byte[] byLRCResult = null;

            //try
            //{
            //    if (null == DataUsedToCalcLRC)
            //    {
            //        throw new Exception("Modbus Ascii 命令字节数组不能为空");
            //    }

            //    // 检查第一个字节是否为 ':'
            //    if (DataUsedToCalcLRC[0] == PrefixByte)
            //    {
            //        byte[] byTemp = DataUsedToCalcLRC;
            //        Array.Copy(DataUsedToCalcLRC, DataUsedToCalcLRC.GetLowerBound(0) + 1, byTemp, 0, DataUsedToCalcLRC.Length - 1); //跳过第一个字节 ':'
            //        DataUsedToCalcLRC = byTemp;
            //    }

            //    // 检查最后2个字节是否为回车或换行符号
            //    if (DataUsedToCalcLRC[DataUsedToCalcLRC.Length - 1] == 0x0D || DataUsedToCalcLRC[DataUsedToCalcLRC.Length - 1] == 0x0A)
            //    {
            //        // 第一次执行
            //        byte[] byTemp = DataUsedToCalcLRC;
            //        Array.Copy(DataUsedToCalcLRC, DataUsedToCalcLRC.GetLowerBound(0), byTemp, 0, DataUsedToCalcLRC.Length - 1);
            //        DataUsedToCalcLRC = byTemp;

            //        // 第二次执行
            //        if (DataUsedToCalcLRC[DataUsedToCalcLRC.Length - 1] == 0x0D || DataUsedToCalcLRC[DataUsedToCalcLRC.Length - 1] == 0x0A)
            //        {
            //            byTemp = DataUsedToCalcLRC;
            //            Array.Copy(DataUsedToCalcLRC, DataUsedToCalcLRC.GetLowerBound(0), byTemp, 0, DataUsedToCalcLRC.Length - 1);
            //            DataUsedToCalcLRC = byTemp;
            //        }
            //    }
            //    else
            //    {
            //        // 如果最后一个字节不是回车或换行符号，但是倒数第二个字节是回车或换行符号，就将最后一个字节的值赋给倒数第二个字节，然后将整个数组的长度-1
            //        if (DataUsedToCalcLRC[DataUsedToCalcLRC.Length - 2] == 0x0D || DataUsedToCalcLRC[DataUsedToCalcLRC.Length - 2] == 0x0A)
            //        {
            //            DataUsedToCalcLRC[DataUsedToCalcLRC.Length - 2] = DataUsedToCalcLRC[DataUsedToCalcLRC.Length - 1];
            //            Array.Resize<byte>(ref DataUsedToCalcLRC, DataUsedToCalcLRC.Length - 1);
            //        }
            //    }

            //    if (DataUsedToCalcLRC.Length % 2 != 0)
            //    {
            //        throw new Exception("Modbus Ascii 命令字节数组长度不正确，应该是2的整数倍");
            //    }

            //    // 计算字节求和值
            //    int iAdditionValue = 0;
            //    byte bySumValue = 0;
            //    for (int i = 0; i < DataUsedToCalcLRC.Length; i++)//
            //    {
            //        iAdditionValue += DataUsedToCalcLRC[i];//
            //    }

            //    // 取字节累加值的第1个字节， int 包含 4 个字节
            //    byte[] byLatestTemp = BitConverter.GetBytes(iAdditionValue);
            //    bySumValue = byLatestTemp[0];

            //    // 取反
            //    bySumValue = Convert.ToByte(255 ^ bySumValue);
            //    //bySumValue = (byte)(255 - bySumValue);

            //    // +1
            //    bySumValue += 1;

            //    byLRCResult = new byte[2];
            //    string sLRCResult = bySumValue.ToString("X2");
            //    for (int i = 0; i < byLRCResult.Length; i++)
            //    {
            //        byLRCResult[i] = Convert.ToByte(sLRCResult[i]);
            //    }
            //}
            //catch (Exception)// ex)
            //{
            //    //Enqueue(ex.Message + "  " + ex.StackTrace);
            //}

            //return byLRCResult;

            #endregion
        }

        /// <summary>
        /// 计算LRC值，返回值的16进制字符串 -- 格式：地址(2个字符) + 功能码(2个字符) + 起始地址(4个字符) + 数据长度(4个字符)
        /// </summary>
        /// <param name="ModbusAsciiCommand">16进制字符串</param>
        /// <returns></returns>
        public static string CalcLRCString(string ModbusAsciiCommand)
        {
            return Converter.Modbus.CLRC.CalcLRCString(ModbusAsciiCommand);

            #region "Old codes - no use"

            //try
            //{
            //    if (string.IsNullOrEmpty(ModbusAsciiCommand) == true)
            //    {
            //        throw new Exception("Modbus Ascii 命令字符串不能为空");
            //    }

            //    if (ModbusAsciiCommand[0] == ':')
            //    {
            //        ModbusAsciiCommand = ModbusAsciiCommand.Remove(0, 1);
            //    }

            //    if (Strings.Left(ModbusAsciiCommand, 2) == "\r\n")
            //    {
            //        ModbusAsciiCommand = ModbusAsciiCommand.Remove(ModbusAsciiCommand.Length - 2, 2);
            //    }

            //    if (ModbusAsciiCommand.Length % 2 != 0)
            //    {
            //        throw new Exception("Modbus Ascii 命令字符串长度不正确，应该是2的整数倍");
            //    }

            //    // 执行写的时候，命令字符串的长度不是固定的
            //    //if (ModbusAsciiCommand.Length != 10)
            //    //{
            //    //    
            //    //}

            //    //byte[] byCommandStringToBytes = Encoding.ASCII.GetBytes(ModbusAsciiCommand);

            //    byte[] byBytesToCalcLRC = new byte[ModbusAsciiCommand.Length / 2];

            //    for (int i = 0; i < ModbusAsciiCommand.Length / 2; i++)
            //    {
            //        string sTemp = Strings.Mid(ModbusAsciiCommand, i * 2 + 1, 2);

            //        byBytesToCalcLRC[i] = CConverter.TwoHexCharsToByte(sTemp);
            //    }

            //    // 计算字节求和值
            //    int iAdditionValue = 0;
            //    byte bySumValue = 0;
            //    for (int i = 0; i < byBytesToCalcLRC.Length; i++)//  byCommandStringToBytes
            //    {
            //        iAdditionValue += byBytesToCalcLRC[i];//  byCommandStringToBytes
            //    }

            //    // 取字节累加值的第1个字节， int 包含 4 个字节
            //    byte[] byLatestTemp = BitConverter.GetBytes(iAdditionValue);
            //    bySumValue = byLatestTemp[0];

            //    // 取反
            //    bySumValue = Convert.ToByte(255 ^ bySumValue);
            //    //bySumValue = (byte)(255 - bySumValue);

            //    // +1
            //    bySumValue += 1;

            //    return bySumValue.ToString("X2");
            //}
            //catch (Exception)// ex)
            //{
            //    //Enqueue(ex.Message + "  " + ex.StackTrace);
            //    return "";
            //}

            #endregion
        }

        /// <summary>
        /// 将客户端返回的字节信息进行计算LRC，确认匹配OK就返回true，否则返回 false
        /// </summary>
        /// <param name="ReceivedBytesFromSlave">客户端返回的字节信息</param>
        /// <returns>匹配OK就返回true，否则返回 false</returns>
        public static bool CalcLRCForReceivedBytesFromSlave(byte[] ReceivedBytesFromSlave)
        {
            return Converter.Modbus.CLRC.CalcLRCForReceivedBytesFromSlave(ReceivedBytesFromSlave);

            #region "Old codes - no use"

            //try
            //{
            //    if (null == ReceivedBytesFromSlave)
            //    {
            //        return false;
            //    }

            //    if (ReceivedBytesFromSlave.Length <= 4)
            //    {
            //        throw new Exception("客户端返回的字符串信息长度不足以进行计算LRC");
            //    }

            //    //:         地址码         功能码    设置起始地址   设置值      LRC     回车+换行符
            //    //1字符     2字符          2字符     4字符          4字符      2字符    2字符
            //    //1字节     1字节          1字节     2字节          2字节      1字节    2字节

            //    // 求 LRC -- 设备地址(2个字符) + 功能码(2个字符) + 起始地址(4个字符) + 数据值(4个字符)

            //    byte[] byUsedToCalcLRC = new byte[ReceivedBytesFromSlave.Length - 3];
            //    Array.Copy(ReceivedBytesFromSlave, 1, byUsedToCalcLRC, 0, byUsedToCalcLRC.Length);

            //    byte[] byLRCResult = CalcLRCBytes(byUsedToCalcLRC);

            //    if (null == byLRCResult || byLRCResult.Length != 2)
            //    {
            //        return false;
            //    }

            //    if (ReceivedBytesFromSlave[ReceivedBytesFromSlave.Length - 2] == byLRCResult[0])
            //    {
            //        return true;
            //    }
            //    else
            //    {
            //        return false;
            //    }
            //}
            //catch (Exception)
            //{
            //    return false;
            //}

            #endregion
        }

        /// <summary>
        /// 将客户端返回的字符串信息进行计算LRC，确认匹配OK就返回true，否则返回 false
        /// </summary>
        /// <param name="ReceivedStringFromSlave">客户端返回的字符串信息</param>
        /// <returns>匹配OK就返回true，否则返回 false</returns>
        public static bool CalcLRCForReceivedStringFromSlave(string ReceivedStringFromSlave)
        {
            return Converter.Modbus.CLRC.CalcLRCForReceivedStringFromSlave(ReceivedStringFromSlave);

            #region "Old codes - no use"

            //try
            //{
            //    if (string.IsNullOrEmpty(ReceivedStringFromSlave) == true)
            //    {
            //        return false;
            //    }

            //    if (ReceivedStringFromSlave.Length <= 4)
            //    {
            //        throw new Exception("客户端返回的字符串信息长度不足以进行计算LRC");
            //    }

            //    //:         地址码         功能码    设置起始地址   设置值      LRC     回车+换行符
            //    //1字符     2字符          2字符     4字符          4字符      2字符    2字符
            //    //1字节     1字节          1字节     2字节          2字节      1字节    2字节

            //    //求 LRC -- 设备地址(2个字符) + 功能码(2个字符) + 起始地址(4个字符) + 数据值(4个字符)

            //    //*****************************************
            //    //(COM1)发送字符串 - :01050000FF00FB
            //    //(COM1)收到字符串 - :01850179  -- 写从站线圈失败后，

            //    //(COM1)发送字符串 - :01050000FF00FB
            //    //(COM1)收到字符串 - :01050000FF00FB  -- 成功写从站后，从站返回的字符串内容与发送的字符串内容相同

            //    //:01050000FF00FB\r\n
            //    //FB
            //    string sReceivedLRC = Strings.Mid(ReceivedStringFromSlave, ReceivedStringFromSlave.Length - 3, 2);
            //    string sUsedToCalcLRC = Strings.Mid(ReceivedStringFromSlave, 2, ReceivedStringFromSlave.Length - 5);
            //    string sLRCCalcResult = CalcLRCString(sUsedToCalcLRC);

            //    if (string.IsNullOrEmpty(sLRCCalcResult) == true)
            //    {
            //        return false;
            //    }

            //    if (sReceivedLRC == sLRCCalcResult)
            //    {
            //        return true;
            //    }
            //    else
            //    {
            //        return false;
            //    }
            //}
            //catch (Exception)
            //{
            //    return false;
            //}

            #endregion
        }

        #region "#region "下面代码移到 Converter 项目下面的 Converter 类""

        ///// <summary>
        ///// 将字节数组转换为16进制字符串，且用字符进行分隔
        ///// </summary>
        ///// <param name="ByteData">字节数组</param>
        ///// <param name="SplitChar">分割字符</param>
        ///// <returns></returns>
        //public static string BytesToHexStringSplitByChar(byte[] ByteData, char SplitChar = ' ')
        //{
        //    string sResult = "";

        //    try
        //    {
        //        if (null != ByteData && ByteData.Length > 0)
        //        {
        //            for (int i = 0; i < ByteData.Length; i++)
        //            {
        //                sResult += ByteData[i].ToString("X2") + SplitChar;
        //            }
        //        }
        //    }
        //    catch (Exception)// ex)
        //    {
        //        //Enqueue(ex.Message + "  " + ex.StackTrace);
        //    }

        //    return sResult;
        //}

        ///// <summary>
        ///// 将16进制字符串(用字符进行分隔)转换为ASCII码字符串
        ///// </summary>
        ///// <param name="HexStringSplitByChar">16进制字符串(用字符进行分隔)</param>
        ///// <param name="SplitChar">分割字符</param>
        ///// <returns></returns>
        //public static string HexStringSplitByCharToASCIIString(string HexStringSplitByChar, char SplitChar = ' ')
        //{
        //    string sResult = "";

        //    try
        //    {
        //        if (string.IsNullOrEmpty(HexStringSplitByChar) == true)
        //        {
        //            return "";
        //        }

        //        string[] sHexString = HexStringSplitByChar.Split(SplitChar);
        //        byte[] byConvertData = new byte[sHexString.Length];
        //        if (null == sHexString && sHexString.Length < 1)
        //        {
        //            return "";   
        //        }
        //        else
        //        {
        //            for (int i = 0; i < sHexString.Length; i++)
        //            {
        //                byConvertData[i] = CConverter.TwoHexCharsToByte(sHexString[i]);
        //            }

        //            sResult = Encoding.ASCII.GetString(byConvertData);
        //        }
        //    }
        //    catch (Exception)// ex)
        //    {
        //        //Enqueue(ex.Message + "  " + ex.StackTrace);
        //    }

        //    return sResult;
        //}

        ///// <summary>
        ///// 拼接两个字节数组，将第二个字节数组拼接在第一个字节数组后面
        ///// </summary>
        ///// <param name="FirstBytes"></param>
        ///// <param name="SecondBytes"></param>
        ///// <returns></returns>
        //public static byte[] JoinTwoByteArrays(byte[] FirstBytes, byte[] SecondBytes)
        //{
        //    if (null == FirstBytes && null == SecondBytes)
        //    {
        //        return null;
        //    }

        //    if (null == FirstBytes)
        //    {
        //        return SecondBytes;
        //    }

        //    if (null == SecondBytes)
        //    {
        //        return FirstBytes;
        //    }

        //    byte[] byResult = new byte[FirstBytes.Length + SecondBytes.Length];
        //    Array.Copy(FirstBytes, byResult, FirstBytes.Length);
        //    Array.Copy(SecondBytes, 0, byResult, FirstBytes.Length, SecondBytes.Length);

        //    return byResult;
        //}

        ///// <summary>
        ///// 将2位16进制数字符串转换为10进制byte值，例：FF - 255
        ///// </summary>
        ///// <param name="TwoHexChars">2位16进制数字符串</param>
        ///// <returns></returns>
        //public static byte CConverter.TwoHexCharsToByte(string TwoHexChars)
        //{
        //    int iResultValue = 0;

        //    try
        //    {
        //        if (string.IsNullOrEmpty(TwoHexChars) == true || TwoHexChars.Length > 2)
        //        {
        //            throw new Exception("执行转换的16进制字符串必须是不大于2个字符");
        //        }

        //        #region "将2位16进制数转换为10进制整数值"

        //        TwoHexChars = TwoHexChars.ToUpper();

        //        int iPowIndex = 0;
        //        int iLengthOfHexString = TwoHexChars.Length;

        //        for (int j = iLengthOfHexString - 1; j >= 0; j--)//for (int j = 0; j < TwoHexChars.Length; j++)
        //        {
        //            char cSingleValue = TwoHexChars[j];//TwoHexChars[j];

        //            iPowIndex = iLengthOfHexString - j - 1;

        //            switch (cSingleValue)
        //            {
        //                case '0':


        //                    break;

        //                case '1':
        //                    iResultValue += 1 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(1) * 16;
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(1);
        //                    //}

        //                    break;

        //                case '2':
        //                    iResultValue += 2 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(2) * 16;
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(2);
        //                    //}

        //                    break;

        //                case '3':
        //                    iResultValue += 3 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(3) * 16;
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(3);
        //                    //}

        //                    break;

        //                case '4':
        //                    iResultValue += 4 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(4) * 16;
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(4);
        //                    //}

        //                    break;

        //                case '5':
        //                    iResultValue += 5 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(5) * 16;
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(5);
        //                    //}

        //                    break;

        //                case '6':
        //                    iResultValue += 6 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(6) * 16;
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(6);
        //                    //}

        //                    break;

        //                case '7':
        //                    iResultValue += 7 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(7) * 16;
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(7);
        //                    //}

        //                    break;

        //                case '8':
        //                    iResultValue += 8 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(8) * 16;
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(8);
        //                    //}

        //                    break;

        //                case '9':
        //                    iResultValue += 9 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(9) * 16;
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(9);
        //                    //}

        //                    break;

        //                case 'A':
        //                    iResultValue += 10 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(10 * 16);
        //                    //    //iValue1 += Convert.ToByte(10 * 16);
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(10);
        //                    //    //iValue1 += Convert.ToByte(10);
        //                    //}

        //                    break;

        //                case 'B':
        //                    iResultValue += 11 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(11 * 16);
        //                    //    //iValue1 += Convert.ToByte(11 * 16);
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(11);
        //                    //    //iValue1 += Convert.ToByte(11);
        //                    //}

        //                    break;

        //                case 'C':
        //                    iResultValue += 12 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(12 * 16);
        //                    //    //iValue1 += Convert.ToByte(12 * 16);
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(12);
        //                    //    //iValue1 += Convert.ToByte(12);
        //                    //}

        //                    break;

        //                case 'D':
        //                    iResultValue += 13 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(13 * 16);
        //                    //    //iValue1 += Convert.ToByte(13 * 16);
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(13);
        //                    //    //iValue1 += Convert.ToByte(13);
        //                    //}

        //                    break;

        //                case 'E':
        //                    iResultValue += 14 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(14 * 16);
        //                    //    //iValue1 += Convert.ToByte(14 * 16);
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(14);
        //                    //    //iValue1 += Convert.ToByte(14);
        //                    //}

        //                    break;

        //                case 'F':
        //                    iResultValue += 15 * Convert.ToInt32(Math.Pow(16, iPowIndex));
        //                    //if (j == 0)
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(15 * 16);
        //                    //    //iValue1 += Convert.ToByte(15 * 16);
        //                    //}
        //                    //else
        //                    //{
        //                    //    iResultValue += Convert.ToInt32(15);
        //                    //    //iValue1 += Convert.ToByte(15);
        //                    //}

        //                    break;

        //                default:
        //                    throw new Exception("执行转换的16进制字符为非法字符");
        //            }
        //        }

        //        #endregion
        //    }
        //    catch (Exception)// ex)
        //    {
        //        //Enqueue(ex.Message + "  " + ex.StackTrace);
        //    }

        //    return (byte)iResultValue;
        //}

        ///// <summary>
        ///// 字节转换为2为16进制字符
        ///// </summary>
        ///// <param name="ByteData">字节</param>
        ///// <returns>是否成功执行</returns>
        //public static string ByteToTwoHexChars(byte ByteData)
        //{
        //    return ByteData.ToString("X2");;
        //}

        ///// <summary>
        ///// 字节值按位转换为布尔数组
        ///// </summary>
        ///// <param name="ByteValue">字节值</param>
        ///// <returns></returns>
        //public static bool[] ByteToBitArray(byte ByteValue)
        //{
        //    try
        //    {
        //        bool[] bResult = new bool[8];
        //        byte byTemp = 0x0;

        //        for (int i = 0; i < bResult.Length; i++)
        //        {
        //            byTemp = Convert.ToByte(ByteValue >> i);
        //            if ((byTemp & 1) == 1)
        //            {
        //                bResult[i] = true;
        //            }
        //            else
        //            {
        //                bResult[i] = false;
        //            }
        //        }

        //        return bResult;
        //    }
        //    catch (Exception)// ex)
        //    {
        //        //Enqueue(ex.Message + ", " + ex.StackTrace);
        //        return null;
        //    }
        //}

        ///// <summary>
        ///// 布尔数组转换为字节数组
        ///// </summary>
        ///// <param name="BitValue">布尔数组</param>
        ///// <returns></returns>
        //public static byte[] BitArrayToByte(bool[] BitValue)
        //{
        //    try
        //    {
        //        if (BitValue.Length % 8 != 0)
        //        {
        //            throw new Exception("bool[]数组的长度不是8的整数，即不是以整字节的形式，请修改参数数组的长度");
        //        }

        //        byte[] byResult = new byte[BitValue.Length / 8];
        //        byte byTemp = 0x0;

        //        // 以8个BOOL数组长度为一个字节来进行计算，可以用或
        //        for (int j = 0; j < byResult.Length; j++)
        //        {
        //            byTemp = 0x0;
        //            int iBeginIndex = j * 8;
        //            for (int i = iBeginIndex; i < iBeginIndex + 8; i++)
        //            {
        //                if (BitValue[i] == true)
        //                {
        //                    byTemp |= Convert.ToByte(0x1 << (i - iBeginIndex));//
        //                }
        //                else
        //                {

        //                }
        //            }

        //            byResult[j] = byTemp;
        //        }

        //        #region "Old codes"

        //        //byte[] byResult = new byte[BitValue.Length / 8];
        //        //int iTemp = 0x0;

        //        //// 以8个BOOL数组长度为一个字节来进行计算，可以用或
        //        //for (int j = 0; j < byResult.Length; j++)
        //        //{
        //        //    iTemp = 0x0;
        //        //    int iBeginIndex = j * 8;
        //        //    for (int i = iBeginIndex; i < iBeginIndex + 8; i++)
        //        //    {
        //        //        if (BitValue[i] == true)
        //        //        {
        //        //            iTemp |= 0x1 << (i - iBeginIndex);//Convert.ToByte(0x1 << i)
        //        //        }
        //        //        else
        //        //        {

        //        //        }
        //        //    }

        //        //    byte[] byIntToBytes = BitConverter.GetBytes(iTemp);
        //        //    byResult[j] = byIntToBytes[0];
        //        //}

        //        #endregion

        //        return byResult;
        //    }
        //    catch (Exception)// ex)
        //    {
        //        //索引超出了数组界限。
        //        //值对于无符号的字节太大或太小。
        //        //Enqueue(ex.Message + ", " + ex.StackTrace);
        //        return null;
        //    }
        //}

        ///// <summary>
        ///// 将int整型值转换为字节数组
        ///// </summary>
        ///// <param name="IntValue">int整型值</param>
        ///// <returns></returns>
        //public static byte[]CConverter.ToBytes(int IntValue)
        //{
        //    byte[] byResult = BitConverter.GetBytes(IntValue);
        //    return byResult;
        //}

        ///// <summary>
        ///// 将int整型值转换为4个字符的16进制字符串
        ///// </summary>
        ///// <param name="IntValue">int整型值</param>
        ///// <returns></returns>
        //public static string IntToFourHexString(int IntValue)
        //{
        //    return IntValue.ToString("X4");
        //}

        ///// <summary>
        ///// 将4个字符的16进制字符串转换为int整型值
        ///// </summary>
        ///// <param name="HexString">4个字符的16进制字符串</param>
        ///// <returns>int整型值</returns>
        //public static int CConverter.FourHexStringToInt(string HexString)
        //{
        //    if (string.IsNullOrEmpty(HexString) == true)
        //    {
        //        return 0;
        //    }

        //    if (HexString.Length > 8)
        //    {
        //        return 0;
        //    }

        //    try
        //    {
        //        return (int)CConverter.HexStringToLong(HexString);
        //    }
        //    catch (Exception)
        //    {
        //        return 0;
        //    }
        //}

        ///// <summary>
        ///// 将16进制字符串转换为long整型值
        ///// </summary>
        ///// <param name="HexString">16进制字符串</param>
        ///// <returns></returns>
        //public static long CConverter.HexStringToLong(string HexString)
        //{
        //    if (string.IsNullOrEmpty(HexString) == true)
        //    {
        //        return 0;
        //    }

        //    long lResultValue = 0;
        //    int iLengthOfHexString = HexString.Length;

        //    HexString = HexString.ToUpper();

        //    int iIndexOfPow = 0;

        //    try
        //    {
        //        //EFB47820 : 从最后一个字符开始计算16进制对应的10进制数值
        //        for (int j = iLengthOfHexString - 1; j >= 0; j--)
        //        {
        //            #region "将2位16进制数转换为10进制整数值"

        //            if (j == 1)
        //            {

        //            }

        //            char cSingleValue = HexString[j];

        //            iIndexOfPow = iLengthOfHexString - j - 1;

        //            switch (cSingleValue)
        //            {
        //                case '0':
        //                    //lResultValue += 0;

        //                    break;

        //                case '1':
        //                    lResultValue += 1 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case '2':
        //                    lResultValue += 2 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case '3':
        //                    lResultValue += 3 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case '4':
        //                    lResultValue += 4 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case '5':
        //                    lResultValue += 5 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case '6':
        //                    lResultValue += 6 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case '7':
        //                    lResultValue += 7 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case '8':
        //                    lResultValue += 8 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case '9':

        //                    lResultValue += 9 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case 'A':
        //                    lResultValue += 10 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case 'B':
        //                    lResultValue += 11 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case 'C':
        //                    lResultValue += 12 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case 'D':
        //                    lResultValue += 13 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case 'E':
        //                    lResultValue += 14 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                case 'F':
        //                    lResultValue += 15 * Convert.ToInt64(Math.Pow(16, iIndexOfPow));

        //                    break;

        //                default:
        //                    throw new Exception("执行转换的16进制字符为非法字符");
        //                    //Enqueue("执行转换的16进制字符为非法字符");
        //                    //break;
        //            }

        //            #endregion

        //            iIndexOfPow++;
        //        }
        //    }
        //    catch (Exception)// ex)
        //    {
        //        //Enqueue(ex.Message + ", " + ex.StackTrace);
        //    }

        //    return lResultValue;
        //}

        #endregion

        #endregion

        #endregion

    }//class

}//namespace